nohup: ignoring input
Using a slow image processor as `use_fast` is unset and a slow processor was saved with this model. `use_fast=True` will be the default behavior in v4.52, even if the model was saved with a slow processor. This will result in minor differences in outputs. You'll still be able to use a slow processor with `use_fast=False`.
Loading checkpoint shards:   0%|          | 0/5 [00:00<?, ?it/s]Loading checkpoint shards:  20%|██        | 1/5 [00:00<00:02,  1.64it/s]Loading checkpoint shards:  40%|████      | 2/5 [00:01<00:01,  1.55it/s]Loading checkpoint shards:  60%|██████    | 3/5 [00:01<00:01,  1.51it/s]Loading checkpoint shards:  80%|████████  | 4/5 [00:02<00:00,  1.50it/s]Loading checkpoint shards: 100%|██████████| 5/5 [00:03<00:00,  1.53it/s]Loading checkpoint shards: 100%|██████████| 5/5 [00:03<00:00,  1.53it/s]
/srv/chawak/envs/planwllm/lib/python3.11/site-packages/peft/peft_model.py:569: UserWarning: Found missing adapter keys while loading the checkpoint: ['base_model.model.model.layers.0.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.0.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.0.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.0.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.0.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.0.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.0.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.0.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.0.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.0.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.0.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.0.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.0.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.0.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.1.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.1.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.1.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.1.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.1.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.1.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.1.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.1.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.1.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.1.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.1.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.1.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.1.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.1.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.2.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.2.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.2.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.2.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.2.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.2.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.2.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.2.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.2.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.2.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.2.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.2.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.2.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.2.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.3.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.3.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.3.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.3.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.3.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.3.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.3.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.3.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.3.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.3.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.3.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.3.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.3.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.3.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.4.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.4.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.4.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.4.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.4.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.4.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.4.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.4.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.4.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.4.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.4.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.4.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.4.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.4.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.5.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.5.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.5.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.5.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.5.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.5.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.5.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.5.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.5.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.5.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.5.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.5.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.5.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.5.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.6.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.6.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.6.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.6.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.6.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.6.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.6.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.6.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.6.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.6.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.6.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.6.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.6.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.6.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.7.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.7.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.7.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.7.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.7.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.7.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.7.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.7.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.7.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.7.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.7.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.7.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.7.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.7.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.8.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.8.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.8.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.8.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.8.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.8.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.8.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.8.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.8.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.8.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.8.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.8.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.8.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.8.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.9.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.9.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.9.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.9.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.9.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.9.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.9.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.9.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.9.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.9.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.9.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.9.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.9.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.9.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.10.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.10.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.10.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.10.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.10.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.10.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.10.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.10.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.10.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.10.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.10.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.10.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.10.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.10.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.11.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.11.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.11.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.11.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.11.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.11.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.11.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.11.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.11.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.11.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.11.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.11.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.11.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.11.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.12.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.12.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.12.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.12.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.12.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.12.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.12.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.12.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.12.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.12.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.12.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.12.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.12.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.12.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.13.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.13.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.13.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.13.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.13.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.13.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.13.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.13.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.13.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.13.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.13.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.13.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.13.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.13.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.14.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.14.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.14.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.14.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.14.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.14.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.14.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.14.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.14.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.14.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.14.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.14.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.14.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.14.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.15.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.15.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.15.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.15.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.15.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.15.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.15.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.15.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.15.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.15.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.15.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.15.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.15.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.15.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.16.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.16.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.16.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.16.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.16.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.16.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.16.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.16.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.16.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.16.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.16.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.16.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.16.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.16.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.17.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.17.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.17.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.17.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.17.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.17.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.17.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.17.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.17.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.17.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.17.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.17.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.17.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.17.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.18.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.18.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.18.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.18.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.18.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.18.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.18.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.18.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.18.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.18.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.18.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.18.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.18.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.18.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.19.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.19.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.19.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.19.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.19.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.19.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.19.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.19.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.19.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.19.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.19.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.19.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.19.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.19.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.20.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.20.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.20.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.20.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.20.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.20.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.20.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.20.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.20.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.20.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.20.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.20.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.20.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.20.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.21.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.21.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.21.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.21.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.21.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.21.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.21.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.21.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.21.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.21.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.21.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.21.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.21.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.21.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.22.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.22.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.22.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.22.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.22.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.22.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.22.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.22.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.22.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.22.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.22.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.22.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.22.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.22.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.23.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.23.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.23.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.23.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.23.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.23.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.23.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.23.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.23.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.23.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.23.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.23.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.23.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.23.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.24.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.24.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.24.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.24.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.24.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.24.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.24.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.24.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.24.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.24.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.24.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.24.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.24.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.24.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.25.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.25.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.25.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.25.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.25.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.25.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.25.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.25.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.25.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.25.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.25.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.25.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.25.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.25.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.26.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.26.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.26.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.26.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.26.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.26.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.26.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.26.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.26.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.26.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.26.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.26.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.26.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.26.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.27.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.27.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.27.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.27.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.27.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.27.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.27.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.27.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.27.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.27.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.27.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.27.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.27.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.27.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.28.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.28.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.28.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.28.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.28.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.28.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.28.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.28.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.28.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.28.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.28.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.28.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.28.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.28.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.29.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.29.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.29.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.29.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.29.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.29.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.29.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.29.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.29.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.29.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.29.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.29.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.29.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.29.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.30.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.30.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.30.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.30.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.30.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.30.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.30.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.30.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.30.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.30.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.30.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.30.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.30.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.30.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.31.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.31.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.31.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.31.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.31.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.31.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.31.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.31.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.31.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.31.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.31.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.31.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.31.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.31.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.32.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.32.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.32.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.32.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.32.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.32.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.32.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.32.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.32.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.32.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.32.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.32.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.32.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.32.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.33.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.33.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.33.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.33.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.33.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.33.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.33.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.33.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.33.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.33.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.33.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.33.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.33.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.33.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.34.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.34.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.34.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.34.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.34.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.34.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.34.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.34.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.34.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.34.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.34.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.34.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.34.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.34.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.35.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.35.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.35.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.35.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.35.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.35.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.35.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.35.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.35.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.35.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.35.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.35.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.35.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.35.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.36.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.36.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.36.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.36.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.36.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.36.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.36.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.36.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.36.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.36.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.36.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.36.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.36.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.36.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.37.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.37.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.37.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.37.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.37.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.37.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.37.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.37.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.37.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.37.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.37.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.37.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.37.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.37.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.38.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.38.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.38.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.38.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.38.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.38.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.38.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.38.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.38.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.38.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.38.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.38.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.38.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.38.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.39.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.39.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.39.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.39.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.39.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.39.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.39.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.39.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.39.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.39.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.39.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.39.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.39.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.39.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.40.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.40.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.40.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.40.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.40.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.40.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.40.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.40.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.40.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.40.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.40.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.40.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.40.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.40.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.41.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.41.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.41.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.41.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.41.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.41.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.41.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.41.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.41.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.41.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.41.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.41.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.41.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.41.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.42.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.42.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.42.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.42.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.42.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.42.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.42.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.42.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.42.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.42.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.42.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.42.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.42.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.42.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.43.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.43.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.43.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.43.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.43.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.43.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.43.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.43.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.43.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.43.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.43.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.43.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.43.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.43.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.44.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.44.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.44.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.44.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.44.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.44.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.44.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.44.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.44.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.44.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.44.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.44.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.44.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.44.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.45.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.45.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.45.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.45.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.45.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.45.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.45.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.45.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.45.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.45.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.45.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.45.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.45.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.45.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.46.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.46.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.46.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.46.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.46.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.46.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.46.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.46.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.46.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.46.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.46.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.46.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.46.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.46.mlp.down_proj.lora_B.default.weight', 'base_model.model.model.layers.47.self_attn.q_proj.lora_A.default.weight', 'base_model.model.model.layers.47.self_attn.q_proj.lora_B.default.weight', 'base_model.model.model.layers.47.self_attn.k_proj.lora_A.default.weight', 'base_model.model.model.layers.47.self_attn.k_proj.lora_B.default.weight', 'base_model.model.model.layers.47.self_attn.v_proj.lora_A.default.weight', 'base_model.model.model.layers.47.self_attn.v_proj.lora_B.default.weight', 'base_model.model.model.layers.47.self_attn.o_proj.lora_A.default.weight', 'base_model.model.model.layers.47.self_attn.o_proj.lora_B.default.weight', 'base_model.model.model.layers.47.mlp.gate_proj.lora_A.default.weight', 'base_model.model.model.layers.47.mlp.gate_proj.lora_B.default.weight', 'base_model.model.model.layers.47.mlp.up_proj.lora_A.default.weight', 'base_model.model.model.layers.47.mlp.up_proj.lora_B.default.weight', 'base_model.model.model.layers.47.mlp.down_proj.lora_A.default.weight', 'base_model.model.model.layers.47.mlp.down_proj.lora_B.default.weight'].
  warnings.warn(warn_message)
skipping cudagraphs due to skipping cudagraphs due to multiple devices: device(type='cuda', index=0), device(type='cuda', index=1), device(type='cuda', index=2), device(type='cuda', index=3)


--------------------Entering main loop PROBLEM #0--------------------
State in create_ic (('violet', 'teal', 'brown'),)
State in create_goal (('violet',), ('teal',), ('brown',))


Blocksworld Problem Initial Values:{clear(brown): true, hand_empty: true, on_table(violet): true, on(teal, violet): true, on(brown, teal): true, on(brown, brown): false, on(violet, brown): false, on(teal, brown): false, on(brown, violet): false, on(violet, violet): false, on(violet, teal): false, on(teal, teal): false, clear(violet): false, clear(teal): false, on_table(brown): false, on_table(teal): false, holding(brown): false, holding(violet): false, holding(teal): false}

Blocksworld Problem Goal State:[on_table(violet), on_table(teal), on_table(brown)]
Prompt in the chat-template:<bos><start_of_turn>user
I am playing with a set of blocks where I need to arrange the blocks into stacks
        Here are the actions I can do: Pick up a block, Unstack a block from on top of another block, Put down a block, Stack a block on top of another block.
        I have the following restrictions on my actions:
        I can only pick up or unstack one block at a time
        I can only pick up or unstack a block if my hand is empty
        I can only pick up a block if the block is on the table and the block is clear
        A block is clear if the block has no other blocks on top of it and if the block is not picked up
        I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block
        I can only unstack a block from on top of another block if the block I am unstacking is clear
        Once I pick up or unstack a block, I am holding the block
        I can only put down a block that I am holding
        I can only stack a block on top of another block if I am holding the block being stacked
        I can only stack a block on top of another block if the block onto which I am stacking the block is clear
        Once I put down or stack a block, my hand becomes empty
        Once you stack a block on top of a second block, the second block is no longer clear

[STATEMENT]
As initial conditions I have that, the green block is clear,  the hand is empty, the red block is on the table, the pink block is on top of the red block, the green block is on top of the pink block.
My goal is to have that  the green block is on the table, the red block is on top of the green block, the pink block is on top of the red block.

My plan is as follows:

[PLAN]
unstack the green block from on top of the pink block
put down the green block
unstack the pink block from on top of the red block
put down the pink block
pick up the red block
stack the red block on top of the green block
pick up the pink block
stack the pink block on top of the red block
[PLAN END]

[STATEMENT]
As initial conditions I have that, the brown block is clear,  the hand is empty, the violet block is on the table, the teal block is on top of the violet block, the brown block is on top of the teal block.
My goal is to have that  the violet block is on the table, the teal block is on the table, the brown block is on the table.

My plan is as follows: 

[PLAN]<end_of_turn>



.......Querying LLM for a plan......... iteration: #0
Response from LLM:: 

[PLAN]
model
unstack the brown block from on top of the teal block
put down the brown block
unstack the teal block from on top of the violet block
put down the teal block
pick up the violet block
put down the violet block
[PLAN END]

After EXTRCAT PLAN ACTIONS: ['unstack the brown block from on top of the teal block', 'put down the brown block', 'unstack the teal block from on top of the violet block', 'put down the teal block', 'pick up the violet block', 'put down the violet block']


Proposed actions by LLM : [('unstack', 'brown', 'teal'), ('put-down', 'brown'), ('unstack', 'teal', 'violet'), ('put-down', 'teal'), ('pick-up', 'violet'), ('put-down', 'violet')] 
  END
LLM PLAN: SequentialPlan:
    unstack(brown, teal)
    put_down(brown)
    unstack(teal, violet)
    put_down(teal)
    pick_up(violet)
    put_down(violet)


Entering "CHECK & APPLY"

 Valid actions so far : 0

 Current State : {clear(brown): true, hand_empty: true, on_table(violet): true, on(teal, violet): true, on(brown, teal): true, on(brown, brown): false, on(violet, brown): false, on(teal, brown): false, on(brown, violet): false, on(violet, violet): false, on(violet, teal): false, on(teal, teal): false, clear(violet): false, clear(teal): false, on_table(brown): false, on_table(teal): false, holding(brown): false, holding(violet): false, holding(teal): false}

 Next Action : unstack(brown, teal)

 New State : {on(brown, teal): false, holding(brown): true, clear(teal): true, hand_empty: false, clear(brown): false, on_table(violet): true, on(teal, violet): true, on(brown, brown): false, on(violet, brown): false, on(teal, brown): false, on(brown, violet): false, on(violet, violet): false, on(violet, teal): false, on(teal, teal): false, clear(violet): false, on_table(brown): false, on_table(teal): false, holding(violet): false, holding(teal): false}

---------------------------------

 Valid actions so far : 1

 Current State : {on(brown, teal): false, holding(brown): true, clear(teal): true, hand_empty: false, clear(brown): false, on_table(violet): true, on(teal, violet): true, on(brown, brown): false, on(violet, brown): false, on(teal, brown): false, on(brown, violet): false, on(violet, violet): false, on(violet, teal): false, on(teal, teal): false, clear(violet): false, on_table(brown): false, on_table(teal): false, holding(violet): false, holding(teal): false}

 Next Action : put_down(brown)

 New State : {holding(brown): false, hand_empty: true, clear(brown): true, on_table(brown): true, on(brown, teal): false, clear(teal): true, on_table(violet): true, on(teal, violet): true, on(brown, brown): false, on(violet, brown): false, on(teal, brown): false, on(brown, violet): false, on(violet, violet): false, on(violet, teal): false, on(teal, teal): false, clear(violet): false, on_table(teal): false, holding(violet): false, holding(teal): false}

---------------------------------

 Valid actions so far : 2

 Current State : {holding(brown): false, hand_empty: true, clear(brown): true, on_table(brown): true, on(brown, teal): false, clear(teal): true, on_table(violet): true, on(teal, violet): true, on(brown, brown): false, on(violet, brown): false, on(teal, brown): false, on(brown, violet): false, on(violet, violet): false, on(violet, teal): false, on(teal, teal): false, clear(violet): false, on_table(teal): false, holding(violet): false, holding(teal): false}

 Next Action : unstack(teal, violet)

 New State : {on(teal, violet): false, holding(teal): true, clear(violet): true, hand_empty: false, clear(teal): false, holding(brown): false, clear(brown): true, on_table(brown): true, on(brown, teal): false, on_table(violet): true, on(brown, brown): false, on(violet, brown): false, on(teal, brown): false, on(brown, violet): false, on(violet, violet): false, on(violet, teal): false, on(teal, teal): false, on_table(teal): false, holding(violet): false}

---------------------------------

 Valid actions so far : 3

 Current State : {on(teal, violet): false, holding(teal): true, clear(violet): true, hand_empty: false, clear(teal): false, holding(brown): false, clear(brown): true, on_table(brown): true, on(brown, teal): false, on_table(violet): true, on(brown, brown): false, on(violet, brown): false, on(teal, brown): false, on(brown, violet): false, on(violet, violet): false, on(violet, teal): false, on(teal, teal): false, on_table(teal): false, holding(violet): false}

 Next Action : put_down(teal)

 New State : {holding(teal): false, hand_empty: true, clear(teal): true, on_table(teal): true, on(teal, violet): false, clear(violet): true, holding(brown): false, clear(brown): true, on_table(brown): true, on(brown, teal): false, on_table(violet): true, on(brown, brown): false, on(violet, brown): false, on(teal, brown): false, on(brown, violet): false, on(violet, violet): false, on(violet, teal): false, on(teal, teal): false, holding(violet): false}

---------------------------------

 Valid actions so far : 4

 Current State : {holding(teal): false, hand_empty: true, clear(teal): true, on_table(teal): true, on(teal, violet): false, clear(violet): true, holding(brown): false, clear(brown): true, on_table(brown): true, on(brown, teal): false, on_table(violet): true, on(brown, brown): false, on(violet, brown): false, on(teal, brown): false, on(brown, violet): false, on(violet, violet): false, on(violet, teal): false, on(teal, teal): false, holding(violet): false}

 Next Action : pick_up(violet)

 New State : {on_table(violet): false, holding(violet): true, hand_empty: false, clear(violet): false, holding(teal): false, clear(teal): true, on_table(teal): true, on(teal, violet): false, holding(brown): false, clear(brown): true, on_table(brown): true, on(brown, teal): false, on(brown, brown): false, on(violet, brown): false, on(teal, brown): false, on(brown, violet): false, on(violet, violet): false, on(violet, teal): false, on(teal, teal): false}

---------------------------------

 Valid actions so far : 5

 Current State : {on_table(violet): false, holding(violet): true, hand_empty: false, clear(violet): false, holding(teal): false, clear(teal): true, on_table(teal): true, on(teal, violet): false, holding(brown): false, clear(brown): true, on_table(brown): true, on(brown, teal): false, on(brown, brown): false, on(violet, brown): false, on(teal, brown): false, on(brown, violet): false, on(violet, violet): false, on(violet, teal): false, on(teal, teal): false}

 Next Action : put_down(violet)

 New State : {holding(violet): false, hand_empty: true, clear(violet): true, on_table(violet): true, holding(teal): false, clear(teal): true, on_table(teal): true, on(teal, violet): false, holding(brown): false, clear(brown): true, on_table(brown): true, on(brown, teal): false, on(brown, brown): false, on(violet, brown): false, on(teal, brown): false, on(brown, violet): false, on(violet, violet): false, on(violet, teal): false, on(teal, teal): false}

---------------------------------

 Computing "Actions To Goal"
[96m[1mNOTE: To disable printing of planning engine credits, add this line to your code: `up.shortcuts.get_environment().credits_stream = None`
[0m[96m  *** Credits ***
[0m[96m  * In operation mode `OneshotPlanner` at line 227 of `/srv/chawak/planning-with-llms/src/unifiedplanning_blocksworld.py`, [0m[96myou are using the following planning engine:
[0m[96m  * Engine name: pyperplan
  * Developers:  Albert-Ludwigs-Universität Freiburg (Yusra Alkhazraji, Matthias Frorath, Markus Grützner, Malte Helmert, Thomas Liebetraut, Robert Mattmüller, Manuela Ortlieb, Jendrik Seipp, Tobias Springenberg, Philip Stahl, Jan Wülfing)
[0m[96m  * Description: [0m[96mPyperplan is a lightweight STRIPS planner written in Python.[0m[96m
[0m[96m
[0m

$$$Proposed actions by GOLD PLAN $$$ : ['unstack the brown block from on top of the teal block', 'put down the brown block', 'unstack the teal block from on top of the violet block', 'put down the teal block', '[PLAN END]'] 
 END
GOALS: {'on_table(teal)', 'on_table(brown)', 'on_table(violet)'}
Current state: ['hand_empty', 'clear(violet)', 'on_table(violet)', 'clear(teal)', 'on_table(teal)', 'clear(brown)', 'on_table(brown)']
??????????????Goals met:True


--------------------Entering main loop PROBLEM #1--------------------
State in create_ic (('red', 'pink', 'green'),)
State in create_goal (('pink',), ('red', 'green'))


Blocksworld Problem Initial Values:{clear(green): true, hand_empty: true, on_table(red): true, on(pink, red): true, on(green, pink): true, on(green, green): false, on(red, green): false, on(pink, green): false, on(green, red): false, on(red, red): false, on(red, pink): false, on(pink, pink): false, clear(red): false, clear(pink): false, on_table(green): false, on_table(pink): false, holding(green): false, holding(red): false, holding(pink): false}

Blocksworld Problem Goal State:[on_table(pink), on_table(red), on(green, red)]
Prompt in the chat-template:<bos><start_of_turn>user
I am playing with a set of blocks where I need to arrange the blocks into stacks
        Here are the actions I can do: Pick up a block, Unstack a block from on top of another block, Put down a block, Stack a block on top of another block.
        I have the following restrictions on my actions:
        I can only pick up or unstack one block at a time
        I can only pick up or unstack a block if my hand is empty
        I can only pick up a block if the block is on the table and the block is clear
        A block is clear if the block has no other blocks on top of it and if the block is not picked up
        I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block
        I can only unstack a block from on top of another block if the block I am unstacking is clear
        Once I pick up or unstack a block, I am holding the block
        I can only put down a block that I am holding
        I can only stack a block on top of another block if I am holding the block being stacked
        I can only stack a block on top of another block if the block onto which I am stacking the block is clear
        Once I put down or stack a block, my hand becomes empty
        Once you stack a block on top of a second block, the second block is no longer clear

[STATEMENT]
As initial conditions I have that, the pink block is clear, the red block is clear,  the hand is empty, the green block is on the table, the pink block is on top of the green block, the red block is on the table.
My goal is to have that  the red block is on the table, the pink block is on top of the red block, the green block is on top of the pink block.

My plan is as follows:

[PLAN]
unstack the pink block from on top of the green block
stack the pink block on top of the red block
pick up the green block
stack the green block on top of the pink block
[PLAN END]

[STATEMENT]
As initial conditions I have that, the green block is clear,  the hand is empty, the red block is on the table, the pink block is on top of the red block, the green block is on top of the pink block.
My goal is to have that  the pink block is on the table, the red block is on the table, the green block is on top of the red block.

My plan is as follows: 

[PLAN]<end_of_turn>



.......Querying LLM for a plan......... iteration: #0
Response from LLM:: 

[PLAN]
model
unstack the green block from on top of the pink block
put down the green block
unstack the pink block from on top of the red block
put down the pink block
pick up the green block
stack the green block on top of the red block
[PLAN END]

After EXTRCAT PLAN ACTIONS: ['unstack the green block from on top of the pink block', 'put down the green block', 'unstack the pink block from on top of the red block', 'put down the pink block', 'pick up the green block', 'stack the green block on top of the red block']


Proposed actions by LLM : [('unstack', 'green', 'pink'), ('put-down', 'green'), ('unstack', 'pink', 'red'), ('put-down', 'pink'), ('pick-up', 'green'), ('stack', 'green', 'red')] 
  END
LLM PLAN: SequentialPlan:
    unstack(green, pink)
    put_down(green)
    unstack(pink, red)
    put_down(pink)
    pick_up(green)
    stack(green, red)


Entering "CHECK & APPLY"

 Valid actions so far : 0

 Current State : {clear(green): true, hand_empty: true, on_table(red): true, on(pink, red): true, on(green, pink): true, on(green, green): false, on(red, green): false, on(pink, green): false, on(green, red): false, on(red, red): false, on(red, pink): false, on(pink, pink): false, clear(red): false, clear(pink): false, on_table(green): false, on_table(pink): false, holding(green): false, holding(red): false, holding(pink): false}

 Next Action : unstack(green, pink)

 New State : {on(green, pink): false, holding(green): true, clear(pink): true, hand_empty: false, clear(green): false, on_table(red): true, on(pink, red): true, on(green, green): false, on(red, green): false, on(pink, green): false, on(green, red): false, on(red, red): false, on(red, pink): false, on(pink, pink): false, clear(red): false, on_table(green): false, on_table(pink): false, holding(red): false, holding(pink): false}

---------------------------------

 Valid actions so far : 1

 Current State : {on(green, pink): false, holding(green): true, clear(pink): true, hand_empty: false, clear(green): false, on_table(red): true, on(pink, red): true, on(green, green): false, on(red, green): false, on(pink, green): false, on(green, red): false, on(red, red): false, on(red, pink): false, on(pink, pink): false, clear(red): false, on_table(green): false, on_table(pink): false, holding(red): false, holding(pink): false}

 Next Action : put_down(green)

 New State : {holding(green): false, hand_empty: true, clear(green): true, on_table(green): true, on(green, pink): false, clear(pink): true, on_table(red): true, on(pink, red): true, on(green, green): false, on(red, green): false, on(pink, green): false, on(green, red): false, on(red, red): false, on(red, pink): false, on(pink, pink): false, clear(red): false, on_table(pink): false, holding(red): false, holding(pink): false}

---------------------------------

 Valid actions so far : 2

 Current State : {holding(green): false, hand_empty: true, clear(green): true, on_table(green): true, on(green, pink): false, clear(pink): true, on_table(red): true, on(pink, red): true, on(green, green): false, on(red, green): false, on(pink, green): false, on(green, red): false, on(red, red): false, on(red, pink): false, on(pink, pink): false, clear(red): false, on_table(pink): false, holding(red): false, holding(pink): false}

 Next Action : unstack(pink, red)

 New State : {on(pink, red): false, holding(pink): true, clear(red): true, hand_empty: false, clear(pink): false, holding(green): false, clear(green): true, on_table(green): true, on(green, pink): false, on_table(red): true, on(green, green): false, on(red, green): false, on(pink, green): false, on(green, red): false, on(red, red): false, on(red, pink): false, on(pink, pink): false, on_table(pink): false, holding(red): false}

---------------------------------

 Valid actions so far : 3

 Current State : {on(pink, red): false, holding(pink): true, clear(red): true, hand_empty: false, clear(pink): false, holding(green): false, clear(green): true, on_table(green): true, on(green, pink): false, on_table(red): true, on(green, green): false, on(red, green): false, on(pink, green): false, on(green, red): false, on(red, red): false, on(red, pink): false, on(pink, pink): false, on_table(pink): false, holding(red): false}

 Next Action : put_down(pink)

 New State : {holding(pink): false, hand_empty: true, clear(pink): true, on_table(pink): true, on(pink, red): false, clear(red): true, holding(green): false, clear(green): true, on_table(green): true, on(green, pink): false, on_table(red): true, on(green, green): false, on(red, green): false, on(pink, green): false, on(green, red): false, on(red, red): false, on(red, pink): false, on(pink, pink): false, holding(red): false}

---------------------------------

 Valid actions so far : 4

 Current State : {holding(pink): false, hand_empty: true, clear(pink): true, on_table(pink): true, on(pink, red): false, clear(red): true, holding(green): false, clear(green): true, on_table(green): true, on(green, pink): false, on_table(red): true, on(green, green): false, on(red, green): false, on(pink, green): false, on(green, red): false, on(red, red): false, on(red, pink): false, on(pink, pink): false, holding(red): false}

 Next Action : pick_up(green)

 New State : {on_table(green): false, holding(green): true, hand_empty: false, clear(green): false, holding(pink): false, clear(pink): true, on_table(pink): true, on(pink, red): false, clear(red): true, on(green, pink): false, on_table(red): true, on(green, green): false, on(red, green): false, on(pink, green): false, on(green, red): false, on(red, red): false, on(red, pink): false, on(pink, pink): false, holding(red): false}

---------------------------------

 Valid actions so far : 5

 Current State : {on_table(green): false, holding(green): true, hand_empty: false, clear(green): false, holding(pink): false, clear(pink): true, on_table(pink): true, on(pink, red): false, clear(red): true, on(green, pink): false, on_table(red): true, on(green, green): false, on(red, green): false, on(pink, green): false, on(green, red): false, on(red, red): false, on(red, pink): false, on(pink, pink): false, holding(red): false}

 Next Action : stack(green, red)

 New State : {holding(green): false, clear(red): false, clear(green): true, on(green, red): true, hand_empty: true, on_table(green): false, holding(pink): false, clear(pink): true, on_table(pink): true, on(pink, red): false, on(green, pink): false, on_table(red): true, on(green, green): false, on(red, green): false, on(pink, green): false, on(red, red): false, on(red, pink): false, on(pink, pink): false, holding(red): false}

---------------------------------

 Computing "Actions To Goal"
[96m  *** Credits ***
[0m[96m  * In operation mode `OneshotPlanner` at line 227 of `/srv/chawak/planning-with-llms/src/unifiedplanning_blocksworld.py`, [0m[96myou are using the following planning engine:
[0m[96m  * Engine name: pyperplan
  * Developers:  Albert-Ludwigs-Universität Freiburg (Yusra Alkhazraji, Matthias Frorath, Markus Grützner, Malte Helmert, Thomas Liebetraut, Robert Mattmüller, Manuela Ortlieb, Jendrik Seipp, Tobias Springenberg, Philip Stahl, Jan Wülfing)
[0m[96m  * Description: [0m[96mPyperplan is a lightweight STRIPS planner written in Python.[0m[96m
[0m[96m
[0m

$$$Proposed actions by GOLD PLAN $$$ : ['unstack the green block from on top of the pink block', 'put down the green block', 'unstack the pink block from on top of the red block', 'put down the pink block', 'pick up the green block', 'stack the green block on top of the red block', '[PLAN END]'] 
 END
GOALS: {'on_table(red)', 'on_table(pink)', 'on(green, red)'}
Current state: ['clear(green)', 'on(green, red)', 'hand_empty', 'clear(pink)', 'on_table(pink)', 'on_table(red)']
??????????????Goals met:True


--------------------Entering main loop PROBLEM #2--------------------
State in create_ic (('pink', 'red', 'green'),)
State in create_goal (('red', 'pink'), ('green',))


Blocksworld Problem Initial Values:{clear(green): true, hand_empty: true, on_table(pink): true, on(red, pink): true, on(green, red): true, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(pink, red): false, on(red, red): false, clear(pink): false, clear(red): false, on_table(green): false, on_table(red): false, holding(green): false, holding(pink): false, holding(red): false}

Blocksworld Problem Goal State:[on_table(red), on(pink, red), on_table(green)]
Prompt in the chat-template:<bos><start_of_turn>user
I am playing with a set of blocks where I need to arrange the blocks into stacks
        Here are the actions I can do: Pick up a block, Unstack a block from on top of another block, Put down a block, Stack a block on top of another block.
        I have the following restrictions on my actions:
        I can only pick up or unstack one block at a time
        I can only pick up or unstack a block if my hand is empty
        I can only pick up a block if the block is on the table and the block is clear
        A block is clear if the block has no other blocks on top of it and if the block is not picked up
        I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block
        I can only unstack a block from on top of another block if the block I am unstacking is clear
        Once I pick up or unstack a block, I am holding the block
        I can only put down a block that I am holding
        I can only stack a block on top of another block if I am holding the block being stacked
        I can only stack a block on top of another block if the block onto which I am stacking the block is clear
        Once I put down or stack a block, my hand becomes empty
        Once you stack a block on top of a second block, the second block is no longer clear

[STATEMENT]
As initial conditions I have that, the violet block is clear,  the hand is empty, the brown block is on the table, the teal block is on top of the brown block, the violet block is on top of the teal block.
My goal is to have that  the teal block is on the table, the violet block is on top of the teal block, the brown block is on top of the violet block.

My plan is as follows:

[PLAN]
unstack the violet block from on top of the teal block
put down the violet block
unstack the teal block from on top of the brown block
put down the teal block
pick up the violet block
stack the violet block on top of the teal block
pick up the brown block
stack the brown block on top of the violet block
[PLAN END]

[STATEMENT]
As initial conditions I have that, the green block is clear,  the hand is empty, the pink block is on the table, the red block is on top of the pink block, the green block is on top of the red block.
My goal is to have that  the red block is on the table, the pink block is on top of the red block, the green block is on the table.

My plan is as follows: 

[PLAN]<end_of_turn>
skipping cudagraphs due to skipping cudagraphs due to multiple devices: device(type='cuda', index=0), device(type='cuda', index=1), device(type='cuda', index=2), device(type='cuda', index=3)



.......Querying LLM for a plan......... iteration: #0
Response from LLM:: 

[PLAN]
model
unstack the green block from on top of the red block
put down the green block
unstack the red block from on top of the pink block
put down the red block
pick up the pink block
stack the pink block on top of the red block
pick up the green block
put down the green block
[PLAN END]

After EXTRCAT PLAN ACTIONS: ['unstack the green block from on top of the red block', 'put down the green block', 'unstack the red block from on top of the pink block', 'put down the red block', 'pick up the pink block', 'stack the pink block on top of the red block', 'pick up the green block', 'put down the green block']


Proposed actions by LLM : [('unstack', 'green', 'red'), ('put-down', 'green'), ('unstack', 'red', 'pink'), ('put-down', 'red'), ('pick-up', 'pink'), ('stack', 'pink', 'red'), ('pick-up', 'green'), ('put-down', 'green')] 
  END
LLM PLAN: SequentialPlan:
    unstack(green, red)
    put_down(green)
    unstack(red, pink)
    put_down(red)
    pick_up(pink)
    stack(pink, red)
    pick_up(green)
    put_down(green)


Entering "CHECK & APPLY"

 Valid actions so far : 0

 Current State : {clear(green): true, hand_empty: true, on_table(pink): true, on(red, pink): true, on(green, red): true, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(pink, red): false, on(red, red): false, clear(pink): false, clear(red): false, on_table(green): false, on_table(red): false, holding(green): false, holding(pink): false, holding(red): false}

 Next Action : unstack(green, red)

 New State : {on(green, red): false, holding(green): true, clear(red): true, hand_empty: false, clear(green): false, on_table(pink): true, on(red, pink): true, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(pink, red): false, on(red, red): false, clear(pink): false, on_table(green): false, on_table(red): false, holding(pink): false, holding(red): false}

---------------------------------

 Valid actions so far : 1

 Current State : {on(green, red): false, holding(green): true, clear(red): true, hand_empty: false, clear(green): false, on_table(pink): true, on(red, pink): true, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(pink, red): false, on(red, red): false, clear(pink): false, on_table(green): false, on_table(red): false, holding(pink): false, holding(red): false}

 Next Action : put_down(green)

 New State : {holding(green): false, hand_empty: true, clear(green): true, on_table(green): true, on(green, red): false, clear(red): true, on_table(pink): true, on(red, pink): true, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(pink, red): false, on(red, red): false, clear(pink): false, on_table(red): false, holding(pink): false, holding(red): false}

---------------------------------

 Valid actions so far : 2

 Current State : {holding(green): false, hand_empty: true, clear(green): true, on_table(green): true, on(green, red): false, clear(red): true, on_table(pink): true, on(red, pink): true, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(pink, red): false, on(red, red): false, clear(pink): false, on_table(red): false, holding(pink): false, holding(red): false}

 Next Action : unstack(red, pink)

 New State : {on(red, pink): false, holding(red): true, clear(pink): true, hand_empty: false, clear(red): false, holding(green): false, clear(green): true, on_table(green): true, on(green, red): false, on_table(pink): true, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(pink, red): false, on(red, red): false, on_table(red): false, holding(pink): false}

---------------------------------

 Valid actions so far : 3

 Current State : {on(red, pink): false, holding(red): true, clear(pink): true, hand_empty: false, clear(red): false, holding(green): false, clear(green): true, on_table(green): true, on(green, red): false, on_table(pink): true, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(pink, red): false, on(red, red): false, on_table(red): false, holding(pink): false}

 Next Action : put_down(red)

 New State : {holding(red): false, hand_empty: true, clear(red): true, on_table(red): true, on(red, pink): false, clear(pink): true, holding(green): false, clear(green): true, on_table(green): true, on(green, red): false, on_table(pink): true, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(pink, red): false, on(red, red): false, holding(pink): false}

---------------------------------

 Valid actions so far : 4

 Current State : {holding(red): false, hand_empty: true, clear(red): true, on_table(red): true, on(red, pink): false, clear(pink): true, holding(green): false, clear(green): true, on_table(green): true, on(green, red): false, on_table(pink): true, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(pink, red): false, on(red, red): false, holding(pink): false}

 Next Action : pick_up(pink)

 New State : {on_table(pink): false, holding(pink): true, hand_empty: false, clear(pink): false, holding(red): false, clear(red): true, on_table(red): true, on(red, pink): false, holding(green): false, clear(green): true, on_table(green): true, on(green, red): false, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(pink, red): false, on(red, red): false}

---------------------------------

 Valid actions so far : 5

 Current State : {on_table(pink): false, holding(pink): true, hand_empty: false, clear(pink): false, holding(red): false, clear(red): true, on_table(red): true, on(red, pink): false, holding(green): false, clear(green): true, on_table(green): true, on(green, red): false, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(pink, red): false, on(red, red): false}

 Next Action : stack(pink, red)

 New State : {holding(pink): false, clear(red): false, clear(pink): true, on(pink, red): true, hand_empty: true, on_table(pink): false, holding(red): false, on_table(red): true, on(red, pink): false, holding(green): false, clear(green): true, on_table(green): true, on(green, red): false, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(red, red): false}

---------------------------------

 Valid actions so far : 6

 Current State : {holding(pink): false, clear(red): false, clear(pink): true, on(pink, red): true, hand_empty: true, on_table(pink): false, holding(red): false, on_table(red): true, on(red, pink): false, holding(green): false, clear(green): true, on_table(green): true, on(green, red): false, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(red, red): false}

 Next Action : pick_up(green)

 New State : {on_table(green): false, holding(green): true, hand_empty: false, clear(green): false, holding(pink): false, clear(red): false, clear(pink): true, on(pink, red): true, on_table(pink): false, holding(red): false, on_table(red): true, on(red, pink): false, on(green, red): false, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(red, red): false}

---------------------------------

 Valid actions so far : 7

 Current State : {on_table(green): false, holding(green): true, hand_empty: false, clear(green): false, holding(pink): false, clear(red): false, clear(pink): true, on(pink, red): true, on_table(pink): false, holding(red): false, on_table(red): true, on(red, pink): false, on(green, red): false, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(red, red): false}

 Next Action : put_down(green)

 New State : {holding(green): false, hand_empty: true, clear(green): true, on_table(green): true, holding(pink): false, clear(red): false, clear(pink): true, on(pink, red): true, on_table(pink): false, holding(red): false, on_table(red): true, on(red, pink): false, on(green, red): false, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(red, red): false}

---------------------------------

 Computing "Actions To Goal"
[96m  *** Credits ***
[0m[96m  * In operation mode `OneshotPlanner` at line 227 of `/srv/chawak/planning-with-llms/src/unifiedplanning_blocksworld.py`, [0m[96myou are using the following planning engine:
[0m[96m  * Engine name: pyperplan
  * Developers:  Albert-Ludwigs-Universität Freiburg (Yusra Alkhazraji, Matthias Frorath, Markus Grützner, Malte Helmert, Thomas Liebetraut, Robert Mattmüller, Manuela Ortlieb, Jendrik Seipp, Tobias Springenberg, Philip Stahl, Jan Wülfing)
[0m[96m  * Description: [0m[96mPyperplan is a lightweight STRIPS planner written in Python.[0m[96m
[0m[96m
[0m

$$$Proposed actions by GOLD PLAN $$$ : ['unstack the green block from on top of the red block', 'put down the green block', 'unstack the red block from on top of the pink block', 'put down the red block', 'pick up the pink block', 'stack the pink block on top of the red block', '[PLAN END]'] 
 END
GOALS: {'on_table(red)', 'on_table(green)', 'on(pink, red)'}
Current state: ['hand_empty', 'clear(green)', 'on_table(green)', 'clear(pink)', 'on(pink, red)', 'on_table(red)']
??????????????Goals met:True


--------------------Entering main loop PROBLEM #3--------------------
State in create_ic (('teal', 'violet', 'brown'),)
State in create_goal (('violet',), ('teal',), ('brown',))


Blocksworld Problem Initial Values:{clear(brown): true, hand_empty: true, on_table(teal): true, on(violet, teal): true, on(brown, violet): true, on(brown, brown): false, on(teal, brown): false, on(violet, brown): false, on(brown, teal): false, on(teal, teal): false, on(teal, violet): false, on(violet, violet): false, clear(teal): false, clear(violet): false, on_table(brown): false, on_table(violet): false, holding(brown): false, holding(teal): false, holding(violet): false}

Blocksworld Problem Goal State:[on_table(violet), on_table(teal), on_table(brown)]
Prompt in the chat-template:<bos><start_of_turn>user
I am playing with a set of blocks where I need to arrange the blocks into stacks
        Here are the actions I can do: Pick up a block, Unstack a block from on top of another block, Put down a block, Stack a block on top of another block.
        I have the following restrictions on my actions:
        I can only pick up or unstack one block at a time
        I can only pick up or unstack a block if my hand is empty
        I can only pick up a block if the block is on the table and the block is clear
        A block is clear if the block has no other blocks on top of it and if the block is not picked up
        I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block
        I can only unstack a block from on top of another block if the block I am unstacking is clear
        Once I pick up or unstack a block, I am holding the block
        I can only put down a block that I am holding
        I can only stack a block on top of another block if I am holding the block being stacked
        I can only stack a block on top of another block if the block onto which I am stacking the block is clear
        Once I put down or stack a block, my hand becomes empty
        Once you stack a block on top of a second block, the second block is no longer clear

[STATEMENT]
As initial conditions I have that, the brown block is clear,  the hand is empty, the teal block is on the table, the violet block is on top of the teal block, the brown block is on top of the violet block.
My goal is to have that  the violet block is on the table, the teal block is on top of the violet block, the brown block is on the table.

My plan is as follows:

[PLAN]
unstack the brown block from on top of the violet block
put down the brown block
unstack the violet block from on top of the teal block
put down the violet block
pick up the teal block
stack the teal block on top of the violet block
[PLAN END]

[STATEMENT]
As initial conditions I have that, the brown block is clear,  the hand is empty, the teal block is on the table, the violet block is on top of the teal block, the brown block is on top of the violet block.
My goal is to have that  the violet block is on the table, the teal block is on the table, the brown block is on the table.

My plan is as follows: 

[PLAN]<end_of_turn>



.......Querying LLM for a plan......... iteration: #0
Response from LLM:: 

[PLAN]
model
unstack the brown block from on top of the violet block
put down the brown block
unstack the violet block from on top of the teal block
put down the violet block
pick up the teal block
put down the teal block
[PLAN END]

After EXTRCAT PLAN ACTIONS: ['unstack the brown block from on top of the violet block', 'put down the brown block', 'unstack the violet block from on top of the teal block', 'put down the violet block', 'pick up the teal block', 'put down the teal block']


Proposed actions by LLM : [('unstack', 'brown', 'violet'), ('put-down', 'brown'), ('unstack', 'violet', 'teal'), ('put-down', 'violet'), ('pick-up', 'teal'), ('put-down', 'teal')] 
  END
LLM PLAN: SequentialPlan:
    unstack(brown, violet)
    put_down(brown)
    unstack(violet, teal)
    put_down(violet)
    pick_up(teal)
    put_down(teal)


Entering "CHECK & APPLY"

 Valid actions so far : 0

 Current State : {clear(brown): true, hand_empty: true, on_table(teal): true, on(violet, teal): true, on(brown, violet): true, on(brown, brown): false, on(teal, brown): false, on(violet, brown): false, on(brown, teal): false, on(teal, teal): false, on(teal, violet): false, on(violet, violet): false, clear(teal): false, clear(violet): false, on_table(brown): false, on_table(violet): false, holding(brown): false, holding(teal): false, holding(violet): false}

 Next Action : unstack(brown, violet)

 New State : {on(brown, violet): false, holding(brown): true, clear(violet): true, hand_empty: false, clear(brown): false, on_table(teal): true, on(violet, teal): true, on(brown, brown): false, on(teal, brown): false, on(violet, brown): false, on(brown, teal): false, on(teal, teal): false, on(teal, violet): false, on(violet, violet): false, clear(teal): false, on_table(brown): false, on_table(violet): false, holding(teal): false, holding(violet): false}

---------------------------------

 Valid actions so far : 1

 Current State : {on(brown, violet): false, holding(brown): true, clear(violet): true, hand_empty: false, clear(brown): false, on_table(teal): true, on(violet, teal): true, on(brown, brown): false, on(teal, brown): false, on(violet, brown): false, on(brown, teal): false, on(teal, teal): false, on(teal, violet): false, on(violet, violet): false, clear(teal): false, on_table(brown): false, on_table(violet): false, holding(teal): false, holding(violet): false}

 Next Action : put_down(brown)

 New State : {holding(brown): false, hand_empty: true, clear(brown): true, on_table(brown): true, on(brown, violet): false, clear(violet): true, on_table(teal): true, on(violet, teal): true, on(brown, brown): false, on(teal, brown): false, on(violet, brown): false, on(brown, teal): false, on(teal, teal): false, on(teal, violet): false, on(violet, violet): false, clear(teal): false, on_table(violet): false, holding(teal): false, holding(violet): false}

---------------------------------

 Valid actions so far : 2

 Current State : {holding(brown): false, hand_empty: true, clear(brown): true, on_table(brown): true, on(brown, violet): false, clear(violet): true, on_table(teal): true, on(violet, teal): true, on(brown, brown): false, on(teal, brown): false, on(violet, brown): false, on(brown, teal): false, on(teal, teal): false, on(teal, violet): false, on(violet, violet): false, clear(teal): false, on_table(violet): false, holding(teal): false, holding(violet): false}

 Next Action : unstack(violet, teal)

 New State : {on(violet, teal): false, holding(violet): true, clear(teal): true, hand_empty: false, clear(violet): false, holding(brown): false, clear(brown): true, on_table(brown): true, on(brown, violet): false, on_table(teal): true, on(brown, brown): false, on(teal, brown): false, on(violet, brown): false, on(brown, teal): false, on(teal, teal): false, on(teal, violet): false, on(violet, violet): false, on_table(violet): false, holding(teal): false}

---------------------------------

 Valid actions so far : 3

 Current State : {on(violet, teal): false, holding(violet): true, clear(teal): true, hand_empty: false, clear(violet): false, holding(brown): false, clear(brown): true, on_table(brown): true, on(brown, violet): false, on_table(teal): true, on(brown, brown): false, on(teal, brown): false, on(violet, brown): false, on(brown, teal): false, on(teal, teal): false, on(teal, violet): false, on(violet, violet): false, on_table(violet): false, holding(teal): false}

 Next Action : put_down(violet)

 New State : {holding(violet): false, hand_empty: true, clear(violet): true, on_table(violet): true, on(violet, teal): false, clear(teal): true, holding(brown): false, clear(brown): true, on_table(brown): true, on(brown, violet): false, on_table(teal): true, on(brown, brown): false, on(teal, brown): false, on(violet, brown): false, on(brown, teal): false, on(teal, teal): false, on(teal, violet): false, on(violet, violet): false, holding(teal): false}

---------------------------------

 Valid actions so far : 4

 Current State : {holding(violet): false, hand_empty: true, clear(violet): true, on_table(violet): true, on(violet, teal): false, clear(teal): true, holding(brown): false, clear(brown): true, on_table(brown): true, on(brown, violet): false, on_table(teal): true, on(brown, brown): false, on(teal, brown): false, on(violet, brown): false, on(brown, teal): false, on(teal, teal): false, on(teal, violet): false, on(violet, violet): false, holding(teal): false}

 Next Action : pick_up(teal)

 New State : {on_table(teal): false, holding(teal): true, hand_empty: false, clear(teal): false, holding(violet): false, clear(violet): true, on_table(violet): true, on(violet, teal): false, holding(brown): false, clear(brown): true, on_table(brown): true, on(brown, violet): false, on(brown, brown): false, on(teal, brown): false, on(violet, brown): false, on(brown, teal): false, on(teal, teal): false, on(teal, violet): false, on(violet, violet): false}

---------------------------------

 Valid actions so far : 5

 Current State : {on_table(teal): false, holding(teal): true, hand_empty: false, clear(teal): false, holding(violet): false, clear(violet): true, on_table(violet): true, on(violet, teal): false, holding(brown): false, clear(brown): true, on_table(brown): true, on(brown, violet): false, on(brown, brown): false, on(teal, brown): false, on(violet, brown): false, on(brown, teal): false, on(teal, teal): false, on(teal, violet): false, on(violet, violet): false}

 Next Action : put_down(teal)

 New State : {holding(teal): false, hand_empty: true, clear(teal): true, on_table(teal): true, holding(violet): false, clear(violet): true, on_table(violet): true, on(violet, teal): false, holding(brown): false, clear(brown): true, on_table(brown): true, on(brown, violet): false, on(brown, brown): false, on(teal, brown): false, on(violet, brown): false, on(brown, teal): false, on(teal, teal): false, on(teal, violet): false, on(violet, violet): false}

---------------------------------

 Computing "Actions To Goal"
[96m  *** Credits ***
[0m[96m  * In operation mode `OneshotPlanner` at line 227 of `/srv/chawak/planning-with-llms/src/unifiedplanning_blocksworld.py`, [0m[96myou are using the following planning engine:
[0m[96m  * Engine name: pyperplan
  * Developers:  Albert-Ludwigs-Universität Freiburg (Yusra Alkhazraji, Matthias Frorath, Markus Grützner, Malte Helmert, Thomas Liebetraut, Robert Mattmüller, Manuela Ortlieb, Jendrik Seipp, Tobias Springenberg, Philip Stahl, Jan Wülfing)
[0m[96m  * Description: [0m[96mPyperplan is a lightweight STRIPS planner written in Python.[0m[96m
[0m[96m
[0m

$$$Proposed actions by GOLD PLAN $$$ : ['unstack the brown block from on top of the violet block', 'put down the brown block', 'unstack the violet block from on top of the teal block', 'put down the violet block', '[PLAN END]'] 
 END
GOALS: {'on_table(teal)', 'on_table(brown)', 'on_table(violet)'}
Current state: ['hand_empty', 'clear(teal)', 'on_table(teal)', 'clear(violet)', 'on_table(violet)', 'clear(brown)', 'on_table(brown)']
??????????????Goals met:True


--------------------Entering main loop PROBLEM #4--------------------
State in create_ic (('pink',), ('green', 'red'))
State in create_goal (('pink',), ('red', 'green'))


Blocksworld Problem Initial Values:{clear(red): true, clear(pink): true, hand_empty: true, on_table(pink): true, on_table(green): true, on(red, green): true, on(red, red): false, on(pink, red): false, on(green, red): false, on(red, pink): false, on(pink, pink): false, on(green, pink): false, on(pink, green): false, on(green, green): false, clear(green): false, on_table(red): false, holding(red): false, holding(pink): false, holding(green): false}

Blocksworld Problem Goal State:[on_table(pink), on_table(red), on(green, red)]
Prompt in the chat-template:<bos><start_of_turn>user
I am playing with a set of blocks where I need to arrange the blocks into stacks
        Here are the actions I can do: Pick up a block, Unstack a block from on top of another block, Put down a block, Stack a block on top of another block.
        I have the following restrictions on my actions:
        I can only pick up or unstack one block at a time
        I can only pick up or unstack a block if my hand is empty
        I can only pick up a block if the block is on the table and the block is clear
        A block is clear if the block has no other blocks on top of it and if the block is not picked up
        I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block
        I can only unstack a block from on top of another block if the block I am unstacking is clear
        Once I pick up or unstack a block, I am holding the block
        I can only put down a block that I am holding
        I can only stack a block on top of another block if I am holding the block being stacked
        I can only stack a block on top of another block if the block onto which I am stacking the block is clear
        Once I put down or stack a block, my hand becomes empty
        Once you stack a block on top of a second block, the second block is no longer clear

[STATEMENT]
As initial conditions I have that, the brown block is clear,  the hand is empty, the teal block is on the table, the violet block is on top of the teal block, the brown block is on top of the violet block.
My goal is to have that  the brown block is on the table, the violet block is on top of the brown block, the teal block is on top of the violet block.

My plan is as follows:

[PLAN]
unstack the brown block from on top of the violet block
put down the brown block
unstack the violet block from on top of the teal block
stack the violet block on top of the brown block
pick up the teal block
stack the teal block on top of the violet block
[PLAN END]

[STATEMENT]
As initial conditions I have that, the red block is clear, the pink block is clear,  the hand is empty, the pink block is on the table, the green block is on the table, the red block is on top of the green block.
My goal is to have that  the pink block is on the table, the red block is on the table, the green block is on top of the red block.

My plan is as follows: 

[PLAN]<end_of_turn>



.......Querying LLM for a plan......... iteration: #0
Response from LLM:: 

[PLAN]
model
unstack the red block from on top of the green block
put down the red block
pick up the green block
stack the green block on top of the red block


After EXTRCAT PLAN ACTIONS: False


.......Querying LLM for a plan......... iteration: #1
Response from LLM:: 

[PLAN]
model
unstack the red block from on top of the green block
put down the red block
pick up the green block
stack the green block on top of the red block


After EXTRCAT PLAN ACTIONS: False


.......Querying LLM for a plan......... iteration: #2
Response from LLM:: 

[PLAN]
model
unstack the red block from on top of the green block
put down the red block
pick up the green block
stack the green block on top of the red block


After EXTRCAT PLAN ACTIONS: False


 LLM exceeded 3 tries


--------------------Entering main loop PROBLEM #5--------------------
State in create_ic (('pink', 'green'), ('red',))
State in create_goal (('red', 'pink'), ('green',))


Blocksworld Problem Initial Values:{clear(red): true, clear(green): true, hand_empty: true, on_table(pink): true, on(green, pink): true, on_table(red): true, on(red, red): false, on(green, red): false, on(pink, red): false, on(red, green): false, on(green, green): false, on(pink, green): false, on(red, pink): false, on(pink, pink): false, clear(pink): false, on_table(green): false, holding(red): false, holding(green): false, holding(pink): false}

Blocksworld Problem Goal State:[on_table(red), on(pink, red), on_table(green)]
Prompt in the chat-template:<bos><start_of_turn>user
I am playing with a set of blocks where I need to arrange the blocks into stacks
        Here are the actions I can do: Pick up a block, Unstack a block from on top of another block, Put down a block, Stack a block on top of another block.
        I have the following restrictions on my actions:
        I can only pick up or unstack one block at a time
        I can only pick up or unstack a block if my hand is empty
        I can only pick up a block if the block is on the table and the block is clear
        A block is clear if the block has no other blocks on top of it and if the block is not picked up
        I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block
        I can only unstack a block from on top of another block if the block I am unstacking is clear
        Once I pick up or unstack a block, I am holding the block
        I can only put down a block that I am holding
        I can only stack a block on top of another block if I am holding the block being stacked
        I can only stack a block on top of another block if the block onto which I am stacking the block is clear
        Once I put down or stack a block, my hand becomes empty
        Once you stack a block on top of a second block, the second block is no longer clear

[STATEMENT]
As initial conditions I have that, the violet block is clear, the brown block is clear,  the hand is empty, the teal block is on the table, the violet block is on top of the teal block, the brown block is on the table.
My goal is to have that  the violet block is on the table, the brown block is on top of the violet block, the teal block is on top of the brown block.

My plan is as follows:

[PLAN]
unstack the violet block from on top of the teal block
put down the violet block
pick up the brown block
stack the brown block on top of the violet block
pick up the teal block
stack the teal block on top of the brown block
[PLAN END]

[STATEMENT]
As initial conditions I have that, the red block is clear, the green block is clear,  the hand is empty, the pink block is on the table, the green block is on top of the pink block, the red block is on the table.
My goal is to have that  the red block is on the table, the pink block is on top of the red block, the green block is on the table.

My plan is as follows: 

[PLAN]<end_of_turn>



.......Querying LLM for a plan......... iteration: #0
Response from LLM:: 

[PLAN]
model
unstack the green block from on top of the pink block
put down the green block
pick up the pink block
stack the pink block on top of the red block
pick up the green block
put down the green block
[PLAN END]

After EXTRCAT PLAN ACTIONS: ['unstack the green block from on top of the pink block', 'put down the green block', 'pick up the pink block', 'stack the pink block on top of the red block', 'pick up the green block', 'put down the green block']


Proposed actions by LLM : [('unstack', 'green', 'pink'), ('put-down', 'green'), ('pick-up', 'pink'), ('stack', 'pink', 'red'), ('pick-up', 'green'), ('put-down', 'green')] 
  END
LLM PLAN: SequentialPlan:
    unstack(green, pink)
    put_down(green)
    pick_up(pink)
    stack(pink, red)
    pick_up(green)
    put_down(green)


Entering "CHECK & APPLY"

 Valid actions so far : 0

 Current State : {clear(red): true, clear(green): true, hand_empty: true, on_table(pink): true, on(green, pink): true, on_table(red): true, on(red, red): false, on(green, red): false, on(pink, red): false, on(red, green): false, on(green, green): false, on(pink, green): false, on(red, pink): false, on(pink, pink): false, clear(pink): false, on_table(green): false, holding(red): false, holding(green): false, holding(pink): false}

 Next Action : unstack(green, pink)

 New State : {on(green, pink): false, holding(green): true, clear(pink): true, hand_empty: false, clear(green): false, clear(red): true, on_table(pink): true, on_table(red): true, on(red, red): false, on(green, red): false, on(pink, red): false, on(red, green): false, on(green, green): false, on(pink, green): false, on(red, pink): false, on(pink, pink): false, on_table(green): false, holding(red): false, holding(pink): false}

---------------------------------

 Valid actions so far : 1

 Current State : {on(green, pink): false, holding(green): true, clear(pink): true, hand_empty: false, clear(green): false, clear(red): true, on_table(pink): true, on_table(red): true, on(red, red): false, on(green, red): false, on(pink, red): false, on(red, green): false, on(green, green): false, on(pink, green): false, on(red, pink): false, on(pink, pink): false, on_table(green): false, holding(red): false, holding(pink): false}

 Next Action : put_down(green)

 New State : {holding(green): false, hand_empty: true, clear(green): true, on_table(green): true, on(green, pink): false, clear(pink): true, clear(red): true, on_table(pink): true, on_table(red): true, on(red, red): false, on(green, red): false, on(pink, red): false, on(red, green): false, on(green, green): false, on(pink, green): false, on(red, pink): false, on(pink, pink): false, holding(red): false, holding(pink): false}

---------------------------------

 Valid actions so far : 2

 Current State : {holding(green): false, hand_empty: true, clear(green): true, on_table(green): true, on(green, pink): false, clear(pink): true, clear(red): true, on_table(pink): true, on_table(red): true, on(red, red): false, on(green, red): false, on(pink, red): false, on(red, green): false, on(green, green): false, on(pink, green): false, on(red, pink): false, on(pink, pink): false, holding(red): false, holding(pink): false}

 Next Action : pick_up(pink)

 New State : {on_table(pink): false, holding(pink): true, hand_empty: false, clear(pink): false, holding(green): false, clear(green): true, on_table(green): true, on(green, pink): false, clear(red): true, on_table(red): true, on(red, red): false, on(green, red): false, on(pink, red): false, on(red, green): false, on(green, green): false, on(pink, green): false, on(red, pink): false, on(pink, pink): false, holding(red): false}

---------------------------------

 Valid actions so far : 3

 Current State : {on_table(pink): false, holding(pink): true, hand_empty: false, clear(pink): false, holding(green): false, clear(green): true, on_table(green): true, on(green, pink): false, clear(red): true, on_table(red): true, on(red, red): false, on(green, red): false, on(pink, red): false, on(red, green): false, on(green, green): false, on(pink, green): false, on(red, pink): false, on(pink, pink): false, holding(red): false}

 Next Action : stack(pink, red)

 New State : {holding(pink): false, clear(red): false, clear(pink): true, on(pink, red): true, hand_empty: true, on_table(pink): false, holding(green): false, clear(green): true, on_table(green): true, on(green, pink): false, on_table(red): true, on(red, red): false, on(green, red): false, on(red, green): false, on(green, green): false, on(pink, green): false, on(red, pink): false, on(pink, pink): false, holding(red): false}

---------------------------------

 Valid actions so far : 4

 Current State : {holding(pink): false, clear(red): false, clear(pink): true, on(pink, red): true, hand_empty: true, on_table(pink): false, holding(green): false, clear(green): true, on_table(green): true, on(green, pink): false, on_table(red): true, on(red, red): false, on(green, red): false, on(red, green): false, on(green, green): false, on(pink, green): false, on(red, pink): false, on(pink, pink): false, holding(red): false}

 Next Action : pick_up(green)

 New State : {on_table(green): false, holding(green): true, hand_empty: false, clear(green): false, holding(pink): false, clear(red): false, clear(pink): true, on(pink, red): true, on_table(pink): false, on(green, pink): false, on_table(red): true, on(red, red): false, on(green, red): false, on(red, green): false, on(green, green): false, on(pink, green): false, on(red, pink): false, on(pink, pink): false, holding(red): false}

---------------------------------

 Valid actions so far : 5

 Current State : {on_table(green): false, holding(green): true, hand_empty: false, clear(green): false, holding(pink): false, clear(red): false, clear(pink): true, on(pink, red): true, on_table(pink): false, on(green, pink): false, on_table(red): true, on(red, red): false, on(green, red): false, on(red, green): false, on(green, green): false, on(pink, green): false, on(red, pink): false, on(pink, pink): false, holding(red): false}

 Next Action : put_down(green)

 New State : {holding(green): false, hand_empty: true, clear(green): true, on_table(green): true, holding(pink): false, clear(red): false, clear(pink): true, on(pink, red): true, on_table(pink): false, on(green, pink): false, on_table(red): true, on(red, red): false, on(green, red): false, on(red, green): false, on(green, green): false, on(pink, green): false, on(red, pink): false, on(pink, pink): false, holding(red): false}

---------------------------------

 Computing "Actions To Goal"
[96m  *** Credits ***
[0m[96m  * In operation mode `OneshotPlanner` at line 227 of `/srv/chawak/planning-with-llms/src/unifiedplanning_blocksworld.py`, [0m[96myou are using the following planning engine:
[0m[96m  * Engine name: pyperplan
  * Developers:  Albert-Ludwigs-Universität Freiburg (Yusra Alkhazraji, Matthias Frorath, Markus Grützner, Malte Helmert, Thomas Liebetraut, Robert Mattmüller, Manuela Ortlieb, Jendrik Seipp, Tobias Springenberg, Philip Stahl, Jan Wülfing)
[0m[96m  * Description: [0m[96mPyperplan is a lightweight STRIPS planner written in Python.[0m[96m
[0m[96m
[0m

$$$Proposed actions by GOLD PLAN $$$ : ['unstack the green block from on top of the pink block', 'put down the green block', 'pick up the pink block', 'stack the pink block on top of the red block', '[PLAN END]'] 
 END
GOALS: {'on_table(red)', 'on_table(green)', 'on(pink, red)'}
Current state: ['hand_empty', 'clear(green)', 'on_table(green)', 'clear(pink)', 'on(pink, red)', 'on_table(red)']
??????????????Goals met:True


--------------------Entering main loop PROBLEM #6--------------------
State in create_ic (('violet',), ('teal',), ('brown',))
State in create_goal (('brown', 'teal', 'violet'),)


Blocksworld Problem Initial Values:{clear(brown): true, clear(teal): true, clear(violet): true, hand_empty: true, on_table(violet): true, on_table(teal): true, on_table(brown): true, on(brown, brown): false, on(teal, brown): false, on(violet, brown): false, on(brown, teal): false, on(teal, teal): false, on(violet, teal): false, on(brown, violet): false, on(teal, violet): false, on(violet, violet): false, holding(brown): false, holding(teal): false, holding(violet): false}

Blocksworld Problem Goal State:[on_table(brown), on(teal, brown), on(violet, teal)]
Prompt in the chat-template:<bos><start_of_turn>user
I am playing with a set of blocks where I need to arrange the blocks into stacks
        Here are the actions I can do: Pick up a block, Unstack a block from on top of another block, Put down a block, Stack a block on top of another block.
        I have the following restrictions on my actions:
        I can only pick up or unstack one block at a time
        I can only pick up or unstack a block if my hand is empty
        I can only pick up a block if the block is on the table and the block is clear
        A block is clear if the block has no other blocks on top of it and if the block is not picked up
        I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block
        I can only unstack a block from on top of another block if the block I am unstacking is clear
        Once I pick up or unstack a block, I am holding the block
        I can only put down a block that I am holding
        I can only stack a block on top of another block if I am holding the block being stacked
        I can only stack a block on top of another block if the block onto which I am stacking the block is clear
        Once I put down or stack a block, my hand becomes empty
        Once you stack a block on top of a second block, the second block is no longer clear

[STATEMENT]
As initial conditions I have that, the pink block is clear, the red block is clear,  the hand is empty, the green block is on the table, the pink block is on top of the green block, the red block is on the table.
My goal is to have that  the pink block is on the table, the red block is on the table, the green block is on top of the red block.

My plan is as follows:

[PLAN]
unstack the pink block from on top of the green block
put down the pink block
pick up the green block
stack the green block on top of the red block
[PLAN END]

[STATEMENT]
As initial conditions I have that, the brown block is clear, the teal block is clear, the violet block is clear,  the hand is empty, the violet block is on the table, the teal block is on the table, the brown block is on the table.
My goal is to have that  the brown block is on the table, the teal block is on top of the brown block, the violet block is on top of the teal block.

My plan is as follows: 

[PLAN]<end_of_turn>



.......Querying LLM for a plan......... iteration: #0
Response from LLM:: 

[PLAN]
model
pick up the violet block
stack the violet block on top of the teal block
pick up the teal block
stack the teal block on top of the brown block
[PLAN END]

After EXTRCAT PLAN ACTIONS: ['pick up the violet block', 'stack the violet block on top of the teal block', 'pick up the teal block', 'stack the teal block on top of the brown block']


Proposed actions by LLM : [('pick-up', 'violet'), ('stack', 'violet', 'teal'), ('pick-up', 'teal'), ('stack', 'teal', 'brown')] 
  END
LLM PLAN: SequentialPlan:
    pick_up(violet)
    stack(violet, teal)
    pick_up(teal)
    stack(teal, brown)


Entering "CHECK & APPLY"

 Valid actions so far : 0

 Current State : {clear(brown): true, clear(teal): true, clear(violet): true, hand_empty: true, on_table(violet): true, on_table(teal): true, on_table(brown): true, on(brown, brown): false, on(teal, brown): false, on(violet, brown): false, on(brown, teal): false, on(teal, teal): false, on(violet, teal): false, on(brown, violet): false, on(teal, violet): false, on(violet, violet): false, holding(brown): false, holding(teal): false, holding(violet): false}

 Next Action : pick_up(violet)

 New State : {on_table(violet): false, holding(violet): true, hand_empty: false, clear(violet): false, clear(brown): true, clear(teal): true, on_table(teal): true, on_table(brown): true, on(brown, brown): false, on(teal, brown): false, on(violet, brown): false, on(brown, teal): false, on(teal, teal): false, on(violet, teal): false, on(brown, violet): false, on(teal, violet): false, on(violet, violet): false, holding(brown): false, holding(teal): false}

---------------------------------

 Valid actions so far : 1

 Current State : {on_table(violet): false, holding(violet): true, hand_empty: false, clear(violet): false, clear(brown): true, clear(teal): true, on_table(teal): true, on_table(brown): true, on(brown, brown): false, on(teal, brown): false, on(violet, brown): false, on(brown, teal): false, on(teal, teal): false, on(violet, teal): false, on(brown, violet): false, on(teal, violet): false, on(violet, violet): false, holding(brown): false, holding(teal): false}

 Next Action : stack(violet, teal)

 New State : {holding(violet): false, clear(teal): false, clear(violet): true, on(violet, teal): true, hand_empty: true, on_table(violet): false, clear(brown): true, on_table(teal): true, on_table(brown): true, on(brown, brown): false, on(teal, brown): false, on(violet, brown): false, on(brown, teal): false, on(teal, teal): false, on(brown, violet): false, on(teal, violet): false, on(violet, violet): false, holding(brown): false, holding(teal): false}

---------------------------------

 Valid actions so far : 2

 Current State : {holding(violet): false, clear(teal): false, clear(violet): true, on(violet, teal): true, hand_empty: true, on_table(violet): false, clear(brown): true, on_table(teal): true, on_table(brown): true, on(brown, brown): false, on(teal, brown): false, on(violet, brown): false, on(brown, teal): false, on(teal, teal): false, on(brown, violet): false, on(teal, violet): false, on(violet, violet): false, holding(brown): false, holding(teal): false}

 Next Action : pick_up(teal)


!! INVALID ACTION SEQUENCE:pick_up(teal)

 Computing "Actions To Goal"
[96m  *** Credits ***
[0m[96m  * In operation mode `OneshotPlanner` at line 227 of `/srv/chawak/planning-with-llms/src/unifiedplanning_blocksworld.py`, [0m[96myou are using the following planning engine:
[0m[96m  * Engine name: pyperplan
  * Developers:  Albert-Ludwigs-Universität Freiburg (Yusra Alkhazraji, Matthias Frorath, Markus Grützner, Malte Helmert, Thomas Liebetraut, Robert Mattmüller, Manuela Ortlieb, Jendrik Seipp, Tobias Springenberg, Philip Stahl, Jan Wülfing)
[0m[96m  * Description: [0m[96mPyperplan is a lightweight STRIPS planner written in Python.[0m[96m
[0m[96m
[0m

$$$Proposed actions by GOLD PLAN $$$ : ['pick up the teal block', 'stack the teal block on top of the brown block', 'pick up the violet block', 'stack the violet block on top of the teal block', '[PLAN END]'] 
 END
GOALS: {'on(teal, brown)', 'on_table(brown)', 'on(violet, teal)'}
Current state: ['clear(violet)', 'on(violet, teal)', 'hand_empty', 'clear(brown)', 'on_table(teal)', 'on_table(brown)']
??????????????Goals met:False


--------------------Entering main loop PROBLEM #7--------------------
State in create_ic (('brown', 'violet'), ('teal',))
State in create_goal (('teal', 'brown', 'violet'),)


Blocksworld Problem Initial Values:{clear(teal): true, clear(violet): true, hand_empty: true, on_table(brown): true, on(violet, brown): true, on_table(teal): true, on(teal, teal): false, on(violet, teal): false, on(brown, teal): false, on(teal, violet): false, on(violet, violet): false, on(brown, violet): false, on(teal, brown): false, on(brown, brown): false, clear(brown): false, on_table(violet): false, holding(teal): false, holding(violet): false, holding(brown): false}

Blocksworld Problem Goal State:[on_table(teal), on(brown, teal), on(violet, brown)]
Prompt in the chat-template:<bos><start_of_turn>user
I am playing with a set of blocks where I need to arrange the blocks into stacks
        Here are the actions I can do: Pick up a block, Unstack a block from on top of another block, Put down a block, Stack a block on top of another block.
        I have the following restrictions on my actions:
        I can only pick up or unstack one block at a time
        I can only pick up or unstack a block if my hand is empty
        I can only pick up a block if the block is on the table and the block is clear
        A block is clear if the block has no other blocks on top of it and if the block is not picked up
        I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block
        I can only unstack a block from on top of another block if the block I am unstacking is clear
        Once I pick up or unstack a block, I am holding the block
        I can only put down a block that I am holding
        I can only stack a block on top of another block if I am holding the block being stacked
        I can only stack a block on top of another block if the block onto which I am stacking the block is clear
        Once I put down or stack a block, my hand becomes empty
        Once you stack a block on top of a second block, the second block is no longer clear

[STATEMENT]
As initial conditions I have that, the pink block is clear, the green block is clear,  the hand is empty, the pink block is on the table, the red block is on the table, the green block is on top of the red block.
My goal is to have that  the green block is on the table, the red block is on top of the green block, the pink block is on top of the red block.

My plan is as follows:

[PLAN]
unstack the green block from on top of the red block
put down the green block
pick up the red block
stack the red block on top of the green block
pick up the pink block
stack the pink block on top of the red block
[PLAN END]

[STATEMENT]
As initial conditions I have that, the teal block is clear, the violet block is clear,  the hand is empty, the brown block is on the table, the violet block is on top of the brown block, the teal block is on the table.
My goal is to have that  the teal block is on the table, the brown block is on top of the teal block, the violet block is on top of the brown block.

My plan is as follows: 

[PLAN]<end_of_turn>



.......Querying LLM for a plan......... iteration: #0
Response from LLM:: 

[PLAN]
model
unstack the violet block from on top of the brown block
put down the violet block
pick up the teal block
stack the teal block on top of the brown block
pick up the violet block
stack the violet block on top of the brown block
[PLAN END]

After EXTRCAT PLAN ACTIONS: ['unstack the violet block from on top of the brown block', 'put down the violet block', 'pick up the teal block', 'stack the teal block on top of the brown block', 'pick up the violet block', 'stack the violet block on top of the brown block']


Proposed actions by LLM : [('unstack', 'violet', 'brown'), ('put-down', 'violet'), ('pick-up', 'teal'), ('stack', 'teal', 'brown'), ('pick-up', 'violet'), ('stack', 'violet', 'brown')] 
  END
LLM PLAN: SequentialPlan:
    unstack(violet, brown)
    put_down(violet)
    pick_up(teal)
    stack(teal, brown)
    pick_up(violet)
    stack(violet, brown)


Entering "CHECK & APPLY"

 Valid actions so far : 0

 Current State : {clear(teal): true, clear(violet): true, hand_empty: true, on_table(brown): true, on(violet, brown): true, on_table(teal): true, on(teal, teal): false, on(violet, teal): false, on(brown, teal): false, on(teal, violet): false, on(violet, violet): false, on(brown, violet): false, on(teal, brown): false, on(brown, brown): false, clear(brown): false, on_table(violet): false, holding(teal): false, holding(violet): false, holding(brown): false}

 Next Action : unstack(violet, brown)

 New State : {on(violet, brown): false, holding(violet): true, clear(brown): true, hand_empty: false, clear(violet): false, clear(teal): true, on_table(brown): true, on_table(teal): true, on(teal, teal): false, on(violet, teal): false, on(brown, teal): false, on(teal, violet): false, on(violet, violet): false, on(brown, violet): false, on(teal, brown): false, on(brown, brown): false, on_table(violet): false, holding(teal): false, holding(brown): false}

---------------------------------

 Valid actions so far : 1

 Current State : {on(violet, brown): false, holding(violet): true, clear(brown): true, hand_empty: false, clear(violet): false, clear(teal): true, on_table(brown): true, on_table(teal): true, on(teal, teal): false, on(violet, teal): false, on(brown, teal): false, on(teal, violet): false, on(violet, violet): false, on(brown, violet): false, on(teal, brown): false, on(brown, brown): false, on_table(violet): false, holding(teal): false, holding(brown): false}

 Next Action : put_down(violet)

 New State : {holding(violet): false, hand_empty: true, clear(violet): true, on_table(violet): true, on(violet, brown): false, clear(brown): true, clear(teal): true, on_table(brown): true, on_table(teal): true, on(teal, teal): false, on(violet, teal): false, on(brown, teal): false, on(teal, violet): false, on(violet, violet): false, on(brown, violet): false, on(teal, brown): false, on(brown, brown): false, holding(teal): false, holding(brown): false}

---------------------------------

 Valid actions so far : 2

 Current State : {holding(violet): false, hand_empty: true, clear(violet): true, on_table(violet): true, on(violet, brown): false, clear(brown): true, clear(teal): true, on_table(brown): true, on_table(teal): true, on(teal, teal): false, on(violet, teal): false, on(brown, teal): false, on(teal, violet): false, on(violet, violet): false, on(brown, violet): false, on(teal, brown): false, on(brown, brown): false, holding(teal): false, holding(brown): false}

 Next Action : pick_up(teal)

 New State : {on_table(teal): false, holding(teal): true, hand_empty: false, clear(teal): false, holding(violet): false, clear(violet): true, on_table(violet): true, on(violet, brown): false, clear(brown): true, on_table(brown): true, on(teal, teal): false, on(violet, teal): false, on(brown, teal): false, on(teal, violet): false, on(violet, violet): false, on(brown, violet): false, on(teal, brown): false, on(brown, brown): false, holding(brown): false}

---------------------------------

 Valid actions so far : 3

 Current State : {on_table(teal): false, holding(teal): true, hand_empty: false, clear(teal): false, holding(violet): false, clear(violet): true, on_table(violet): true, on(violet, brown): false, clear(brown): true, on_table(brown): true, on(teal, teal): false, on(violet, teal): false, on(brown, teal): false, on(teal, violet): false, on(violet, violet): false, on(brown, violet): false, on(teal, brown): false, on(brown, brown): false, holding(brown): false}

 Next Action : stack(teal, brown)

 New State : {holding(teal): false, clear(brown): false, clear(teal): true, on(teal, brown): true, hand_empty: true, on_table(teal): false, holding(violet): false, clear(violet): true, on_table(violet): true, on(violet, brown): false, on_table(brown): true, on(teal, teal): false, on(violet, teal): false, on(brown, teal): false, on(teal, violet): false, on(violet, violet): false, on(brown, violet): false, on(brown, brown): false, holding(brown): false}

---------------------------------

 Valid actions so far : 4

 Current State : {holding(teal): false, clear(brown): false, clear(teal): true, on(teal, brown): true, hand_empty: true, on_table(teal): false, holding(violet): false, clear(violet): true, on_table(violet): true, on(violet, brown): false, on_table(brown): true, on(teal, teal): false, on(violet, teal): false, on(brown, teal): false, on(teal, violet): false, on(violet, violet): false, on(brown, violet): false, on(brown, brown): false, holding(brown): false}

 Next Action : pick_up(violet)

 New State : {on_table(violet): false, holding(violet): true, hand_empty: false, clear(violet): false, holding(teal): false, clear(brown): false, clear(teal): true, on(teal, brown): true, on_table(teal): false, on(violet, brown): false, on_table(brown): true, on(teal, teal): false, on(violet, teal): false, on(brown, teal): false, on(teal, violet): false, on(violet, violet): false, on(brown, violet): false, on(brown, brown): false, holding(brown): false}

---------------------------------

 Valid actions so far : 5

 Current State : {on_table(violet): false, holding(violet): true, hand_empty: false, clear(violet): false, holding(teal): false, clear(brown): false, clear(teal): true, on(teal, brown): true, on_table(teal): false, on(violet, brown): false, on_table(brown): true, on(teal, teal): false, on(violet, teal): false, on(brown, teal): false, on(teal, violet): false, on(violet, violet): false, on(brown, violet): false, on(brown, brown): false, holding(brown): false}

 Next Action : stack(violet, brown)


!! INVALID ACTION SEQUENCE:stack(violet, brown)

 Computing "Actions To Goal"
[96m  *** Credits ***
[0m[96m  * In operation mode `OneshotPlanner` at line 227 of `/srv/chawak/planning-with-llms/src/unifiedplanning_blocksworld.py`, [0m[96myou are using the following planning engine:
[0m[96m  * Engine name: pyperplan
  * Developers:  Albert-Ludwigs-Universität Freiburg (Yusra Alkhazraji, Matthias Frorath, Markus Grützner, Malte Helmert, Thomas Liebetraut, Robert Mattmüller, Manuela Ortlieb, Jendrik Seipp, Tobias Springenberg, Philip Stahl, Jan Wülfing)
[0m[96m  * Description: [0m[96mPyperplan is a lightweight STRIPS planner written in Python.[0m[96m
[0m[96m
[0m

$$$Proposed actions by GOLD PLAN $$$ : ['unstack the violet block from on top of the brown block', 'put down the violet block', 'pick up the brown block', 'stack the brown block on top of the teal block', 'pick up the violet block', 'stack the violet block on top of the brown block', '[PLAN END]'] 
 END
GOALS: {'on(brown, teal)', 'on(violet, brown)', 'on_table(teal)'}
Current state: ['holding(violet)', 'clear(teal)', 'on(teal, brown)', 'on_table(brown)']
??????????????Goals met:False


--------------------Entering main loop PROBLEM #8--------------------
State in create_ic (('pink',), ('red', 'green'))
State in create_goal (('green', 'pink'), ('red',))


Blocksworld Problem Initial Values:{clear(green): true, clear(pink): true, hand_empty: true, on_table(pink): true, on_table(red): true, on(green, red): true, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(red, pink): false, on(pink, red): false, on(red, red): false, clear(red): false, on_table(green): false, holding(green): false, holding(pink): false, holding(red): false}

Blocksworld Problem Goal State:[on_table(green), on(pink, green), on_table(red)]
Prompt in the chat-template:<bos><start_of_turn>user
I am playing with a set of blocks where I need to arrange the blocks into stacks
        Here are the actions I can do: Pick up a block, Unstack a block from on top of another block, Put down a block, Stack a block on top of another block.
        I have the following restrictions on my actions:
        I can only pick up or unstack one block at a time
        I can only pick up or unstack a block if my hand is empty
        I can only pick up a block if the block is on the table and the block is clear
        A block is clear if the block has no other blocks on top of it and if the block is not picked up
        I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block
        I can only unstack a block from on top of another block if the block I am unstacking is clear
        Once I pick up or unstack a block, I am holding the block
        I can only put down a block that I am holding
        I can only stack a block on top of another block if I am holding the block being stacked
        I can only stack a block on top of another block if the block onto which I am stacking the block is clear
        Once I put down or stack a block, my hand becomes empty
        Once you stack a block on top of a second block, the second block is no longer clear

[STATEMENT]
As initial conditions I have that, the red block is clear, the green block is clear,  the hand is empty, the pink block is on the table, the red block is on top of the pink block, the green block is on the table.
My goal is to have that  the green block is on the table, the pink block is on top of the green block, the red block is on top of the pink block.

My plan is as follows:

[PLAN]
unstack the red block from on top of the pink block
put down the red block
pick up the pink block
stack the pink block on top of the green block
pick up the red block
stack the red block on top of the pink block
[PLAN END]

[STATEMENT]
As initial conditions I have that, the green block is clear, the pink block is clear,  the hand is empty, the pink block is on the table, the red block is on the table, the green block is on top of the red block.
My goal is to have that  the green block is on the table, the pink block is on top of the green block, the red block is on the table.

My plan is as follows: 

[PLAN]<end_of_turn>



.......Querying LLM for a plan......... iteration: #0
Response from LLM:: 

[PLAN]
model
unstack the green block from on top of the red block
put down the green block
pick up the pink block
stack the pink block on top of the green block
pick up the red block
put down the red block
[PLAN END]

After EXTRCAT PLAN ACTIONS: ['unstack the green block from on top of the red block', 'put down the green block', 'pick up the pink block', 'stack the pink block on top of the green block', 'pick up the red block', 'put down the red block']


Proposed actions by LLM : [('unstack', 'green', 'red'), ('put-down', 'green'), ('pick-up', 'pink'), ('stack', 'pink', 'green'), ('pick-up', 'red'), ('put-down', 'red')] 
  END
LLM PLAN: SequentialPlan:
    unstack(green, red)
    put_down(green)
    pick_up(pink)
    stack(pink, green)
    pick_up(red)
    put_down(red)


Entering "CHECK & APPLY"

 Valid actions so far : 0

 Current State : {clear(green): true, clear(pink): true, hand_empty: true, on_table(pink): true, on_table(red): true, on(green, red): true, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(red, pink): false, on(pink, red): false, on(red, red): false, clear(red): false, on_table(green): false, holding(green): false, holding(pink): false, holding(red): false}

 Next Action : unstack(green, red)

 New State : {on(green, red): false, holding(green): true, clear(red): true, hand_empty: false, clear(green): false, clear(pink): true, on_table(pink): true, on_table(red): true, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(red, pink): false, on(pink, red): false, on(red, red): false, on_table(green): false, holding(pink): false, holding(red): false}

---------------------------------

 Valid actions so far : 1

 Current State : {on(green, red): false, holding(green): true, clear(red): true, hand_empty: false, clear(green): false, clear(pink): true, on_table(pink): true, on_table(red): true, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(red, pink): false, on(pink, red): false, on(red, red): false, on_table(green): false, holding(pink): false, holding(red): false}

 Next Action : put_down(green)

 New State : {holding(green): false, hand_empty: true, clear(green): true, on_table(green): true, on(green, red): false, clear(red): true, clear(pink): true, on_table(pink): true, on_table(red): true, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(red, pink): false, on(pink, red): false, on(red, red): false, holding(pink): false, holding(red): false}

---------------------------------

 Valid actions so far : 2

 Current State : {holding(green): false, hand_empty: true, clear(green): true, on_table(green): true, on(green, red): false, clear(red): true, clear(pink): true, on_table(pink): true, on_table(red): true, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(red, pink): false, on(pink, red): false, on(red, red): false, holding(pink): false, holding(red): false}

 Next Action : pick_up(pink)

 New State : {on_table(pink): false, holding(pink): true, hand_empty: false, clear(pink): false, holding(green): false, clear(green): true, on_table(green): true, on(green, red): false, clear(red): true, on_table(red): true, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(red, pink): false, on(pink, red): false, on(red, red): false, holding(red): false}

---------------------------------

 Valid actions so far : 3

 Current State : {on_table(pink): false, holding(pink): true, hand_empty: false, clear(pink): false, holding(green): false, clear(green): true, on_table(green): true, on(green, red): false, clear(red): true, on_table(red): true, on(green, green): false, on(pink, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(red, pink): false, on(pink, red): false, on(red, red): false, holding(red): false}

 Next Action : stack(pink, green)

 New State : {holding(pink): false, clear(green): false, clear(pink): true, on(pink, green): true, hand_empty: true, on_table(pink): false, holding(green): false, on_table(green): true, on(green, red): false, clear(red): true, on_table(red): true, on(green, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(red, pink): false, on(pink, red): false, on(red, red): false, holding(red): false}

---------------------------------

 Valid actions so far : 4

 Current State : {holding(pink): false, clear(green): false, clear(pink): true, on(pink, green): true, hand_empty: true, on_table(pink): false, holding(green): false, on_table(green): true, on(green, red): false, clear(red): true, on_table(red): true, on(green, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(red, pink): false, on(pink, red): false, on(red, red): false, holding(red): false}

 Next Action : pick_up(red)

 New State : {on_table(red): false, holding(red): true, hand_empty: false, clear(red): false, holding(pink): false, clear(green): false, clear(pink): true, on(pink, green): true, on_table(pink): false, holding(green): false, on_table(green): true, on(green, red): false, on(green, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(red, pink): false, on(pink, red): false, on(red, red): false}

---------------------------------

 Valid actions so far : 5

 Current State : {on_table(red): false, holding(red): true, hand_empty: false, clear(red): false, holding(pink): false, clear(green): false, clear(pink): true, on(pink, green): true, on_table(pink): false, holding(green): false, on_table(green): true, on(green, red): false, on(green, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(red, pink): false, on(pink, red): false, on(red, red): false}

 Next Action : put_down(red)

 New State : {holding(red): false, hand_empty: true, clear(red): true, on_table(red): true, holding(pink): false, clear(green): false, clear(pink): true, on(pink, green): true, on_table(pink): false, holding(green): false, on_table(green): true, on(green, red): false, on(green, green): false, on(red, green): false, on(green, pink): false, on(pink, pink): false, on(red, pink): false, on(pink, red): false, on(red, red): false}

---------------------------------

 Computing "Actions To Goal"
[96m  *** Credits ***
[0m[96m  * In operation mode `OneshotPlanner` at line 227 of `/srv/chawak/planning-with-llms/src/unifiedplanning_blocksworld.py`, [0m[96myou are using the following planning engine:
[0m[96m  * Engine name: pyperplan
  * Developers:  Albert-Ludwigs-Universität Freiburg (Yusra Alkhazraji, Matthias Frorath, Markus Grützner, Malte Helmert, Thomas Liebetraut, Robert Mattmüller, Manuela Ortlieb, Jendrik Seipp, Tobias Springenberg, Philip Stahl, Jan Wülfing)
[0m[96m  * Description: [0m[96mPyperplan is a lightweight STRIPS planner written in Python.[0m[96m
[0m[96m
[0m

$$$Proposed actions by GOLD PLAN $$$ : ['unstack the green block from on top of the red block', 'put down the green block', 'pick up the pink block', 'stack the pink block on top of the green block', '[PLAN END]'] 
 END
GOALS: {'on_table(red)', 'on(pink, green)', 'on_table(green)'}
Current state: ['hand_empty', 'clear(red)', 'on_table(red)', 'clear(pink)', 'on(pink, green)', 'on_table(green)']
??????????????Goals met:True


--------------------Entering main loop PROBLEM #9--------------------
State in create_ic (('green', 'pink'), ('red',))
State in create_goal (('red', 'pink'), ('green',))


Blocksworld Problem Initial Values:{clear(red): true, clear(pink): true, hand_empty: true, on_table(green): true, on(pink, green): true, on_table(red): true, on(red, red): false, on(pink, red): false, on(green, red): false, on(red, pink): false, on(pink, pink): false, on(green, pink): false, on(red, green): false, on(green, green): false, clear(green): false, on_table(pink): false, holding(red): false, holding(pink): false, holding(green): false}

Blocksworld Problem Goal State:[on_table(red), on(pink, red), on_table(green)]
Prompt in the chat-template:<bos><start_of_turn>user
I am playing with a set of blocks where I need to arrange the blocks into stacks
        Here are the actions I can do: Pick up a block, Unstack a block from on top of another block, Put down a block, Stack a block on top of another block.
        I have the following restrictions on my actions:
        I can only pick up or unstack one block at a time
        I can only pick up or unstack a block if my hand is empty
        I can only pick up a block if the block is on the table and the block is clear
        A block is clear if the block has no other blocks on top of it and if the block is not picked up
        I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block
        I can only unstack a block from on top of another block if the block I am unstacking is clear
        Once I pick up or unstack a block, I am holding the block
        I can only put down a block that I am holding
        I can only stack a block on top of another block if I am holding the block being stacked
        I can only stack a block on top of another block if the block onto which I am stacking the block is clear
        Once I put down or stack a block, my hand becomes empty
        Once you stack a block on top of a second block, the second block is no longer clear

[STATEMENT]
As initial conditions I have that, the violet block is clear, the teal block is clear,  the hand is empty, the violet block is on the table, the brown block is on the table, the teal block is on top of the brown block.
My goal is to have that  the violet block is on the table, the brown block is on top of the violet block, the teal block is on top of the brown block.

My plan is as follows:

[PLAN]
unstack the teal block from on top of the brown block
put down the teal block
pick up the brown block
stack the brown block on top of the violet block
pick up the teal block
stack the teal block on top of the brown block
[PLAN END]

[STATEMENT]
As initial conditions I have that, the red block is clear, the pink block is clear,  the hand is empty, the green block is on the table, the pink block is on top of the green block, the red block is on the table.
My goal is to have that  the red block is on the table, the pink block is on top of the red block, the green block is on the table.

My plan is as follows: 

[PLAN]<end_of_turn>



.......Querying LLM for a plan......... iteration: #0
Response from LLM:: 

[PLAN]
model
unstack the pink block from on top of the green block
put down the pink block
pick up the green block
put down the green block
pick up the pink block
stack the pink block on top of the red block


After EXTRCAT PLAN ACTIONS: False


.......Querying LLM for a plan......... iteration: #1
Response from LLM:: 

[PLAN]
model
unstack the pink block from on top of the green block
put down the pink block
pick up the green block
put down the green block
pick up the pink block
stack the pink block on top of the red block


After EXTRCAT PLAN ACTIONS: False


.......Querying LLM for a plan......... iteration: #2
Response from LLM:: 

[PLAN]
model
unstack the pink block from on top of the green block
put down the pink block
pick up the green block
put down the green block
pick up the pink block
stack the pink block on top of the red block


After EXTRCAT PLAN ACTIONS: False


 LLM exceeded 3 tries


--------------------Entering main loop PROBLEM #10--------------------
State in create_ic (('brown', 'violet'), ('teal',))
State in create_goal (('teal', 'violet', 'brown'),)


Blocksworld Problem Initial Values:{clear(teal): true, clear(violet): true, hand_empty: true, on_table(brown): true, on(violet, brown): true, on_table(teal): true, on(teal, teal): false, on(violet, teal): false, on(brown, teal): false, on(teal, violet): false, on(violet, violet): false, on(brown, violet): false, on(teal, brown): false, on(brown, brown): false, clear(brown): false, on_table(violet): false, holding(teal): false, holding(violet): false, holding(brown): false}

Blocksworld Problem Goal State:[on_table(teal), on(violet, teal), on(brown, violet)]
Prompt in the chat-template:<bos><start_of_turn>user
I am playing with a set of blocks where I need to arrange the blocks into stacks
        Here are the actions I can do: Pick up a block, Unstack a block from on top of another block, Put down a block, Stack a block on top of another block.
        I have the following restrictions on my actions:
        I can only pick up or unstack one block at a time
        I can only pick up or unstack a block if my hand is empty
        I can only pick up a block if the block is on the table and the block is clear
        A block is clear if the block has no other blocks on top of it and if the block is not picked up
        I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block
        I can only unstack a block from on top of another block if the block I am unstacking is clear
        Once I pick up or unstack a block, I am holding the block
        I can only put down a block that I am holding
        I can only stack a block on top of another block if I am holding the block being stacked
        I can only stack a block on top of another block if the block onto which I am stacking the block is clear
        Once I put down or stack a block, my hand becomes empty
        Once you stack a block on top of a second block, the second block is no longer clear

[STATEMENT]
As initial conditions I have that, the green block is clear, the red block is clear,  the hand is empty, the pink block is on the table, the green block is on top of the pink block, the red block is on the table.
My goal is to have that  the pink block is on the table, the green block is on top of the pink block, the red block is on top of the green block.

My plan is as follows:

[PLAN]
pick up the red block
stack the red block on top of the green block
[PLAN END]

[STATEMENT]
As initial conditions I have that, the teal block is clear, the violet block is clear,  the hand is empty, the brown block is on the table, the violet block is on top of the brown block, the teal block is on the table.
My goal is to have that  the teal block is on the table, the violet block is on top of the teal block, the brown block is on top of the violet block.

My plan is as follows: 

[PLAN]<end_of_turn>



.......Querying LLM for a plan......... iteration: #0
Response from LLM:: 

[PLAN]
model
pick up the brown block
stack the brown block on top of the violet block


After EXTRCAT PLAN ACTIONS: False


.......Querying LLM for a plan......... iteration: #1
Response from LLM:: 

[PLAN]
model
pick up the brown block
stack the brown block on top of the violet block


After EXTRCAT PLAN ACTIONS: False


.......Querying LLM for a plan......... iteration: #2
Response from LLM:: 

[PLAN]
model
pick up the brown block
stack the brown block on top of the violet block


After EXTRCAT PLAN ACTIONS: False


 LLM exceeded 3 tries


--------------------Entering main loop PROBLEM #11--------------------
State in create_ic (('red', 'pink', 'green'),)
State in create_goal (('red', 'green', 'pink'),)


Blocksworld Problem Initial Values:{clear(green): true, hand_empty: true, on_table(red): true, on(pink, red): true, on(green, pink): true, on(green, green): false, on(red, green): false, on(pink, green): false, on(green, red): false, on(red, red): false, on(red, pink): false, on(pink, pink): false, clear(red): false, clear(pink): false, on_table(green): false, on_table(pink): false, holding(green): false, holding(red): false, holding(pink): false}

Blocksworld Problem Goal State:[on_table(red), on(green, red), on(pink, green)]
Prompt in the chat-template:<bos><start_of_turn>user
I am playing with a set of blocks where I need to arrange the blocks into stacks
        Here are the actions I can do: Pick up a block, Unstack a block from on top of another block, Put down a block, Stack a block on top of another block.
        I have the following restrictions on my actions:
        I can only pick up or unstack one block at a time
        I can only pick up or unstack a block if my hand is empty
        I can only pick up a block if the block is on the table and the block is clear
        A block is clear if the block has no other blocks on top of it and if the block is not picked up
        I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block
        I can only unstack a block from on top of another block if the block I am unstacking is clear
        Once I pick up or unstack a block, I am holding the block
        I can only put down a block that I am holding
        I can only stack a block on top of another block if I am holding the block being stacked
        I can only stack a block on top of another block if the block onto which I am stacking the block is clear
        Once I put down or stack a block, my hand becomes empty
        Once you stack a block on top of a second block, the second block is no longer clear

[STATEMENT]
As initial conditions I have that, the violet block is clear, the brown block is clear,  the hand is empty, the violet block is on the table, the teal block is on the table, the brown block is on top of the teal block.
My goal is to have that  the brown block is on the table, the teal block is on top of the brown block, the violet block is on top of the teal block.

My plan is as follows:

[PLAN]
unstack the brown block from on top of the teal block
put down the brown block
pick up the teal block
stack the teal block on top of the brown block
pick up the violet block
stack the violet block on top of the teal block
[PLAN END]

[STATEMENT]
As initial conditions I have that, the green block is clear,  the hand is empty, the red block is on the table, the pink block is on top of the red block, the green block is on top of the pink block.
My goal is to have that  the red block is on the table, the green block is on top of the red block, the pink block is on top of the green block.

My plan is as follows: 

[PLAN]<end_of_turn>



.......Querying LLM for a plan......... iteration: #0
Response from LLM:: 

[PLAN]
model
unstack the green block from on top of the pink block
put down the green block
pick up the pink block
stack the pink block on top of the green block
pick up the red block
stack the red block on top of the green block
[PLAN END]

After EXTRCAT PLAN ACTIONS: ['unstack the green block from on top of the pink block', 'put down the green block', 'pick up the pink block', 'stack the pink block on top of the green block', 'pick up the red block', 'stack the red block on top of the green block']skipping cudagraphs due to skipping cudagraphs due to multiple devices: device(type='cuda', index=0), device(type='cuda', index=1), device(type='cuda', index=2), device(type='cuda', index=3)



Proposed actions by LLM : [('unstack', 'green', 'pink'), ('put-down', 'green'), ('pick-up', 'pink'), ('stack', 'pink', 'green'), ('pick-up', 'red'), ('stack', 'red', 'green')] 
  END
LLM PLAN: SequentialPlan:
    unstack(green, pink)
    put_down(green)
    pick_up(pink)
    stack(pink, green)
    pick_up(red)
    stack(red, green)


Entering "CHECK & APPLY"

 Valid actions so far : 0

 Current State : {clear(green): true, hand_empty: true, on_table(red): true, on(pink, red): true, on(green, pink): true, on(green, green): false, on(red, green): false, on(pink, green): false, on(green, red): false, on(red, red): false, on(red, pink): false, on(pink, pink): false, clear(red): false, clear(pink): false, on_table(green): false, on_table(pink): false, holding(green): false, holding(red): false, holding(pink): false}

 Next Action : unstack(green, pink)

 New State : {on(green, pink): false, holding(green): true, clear(pink): true, hand_empty: false, clear(green): false, on_table(red): true, on(pink, red): true, on(green, green): false, on(red, green): false, on(pink, green): false, on(green, red): false, on(red, red): false, on(red, pink): false, on(pink, pink): false, clear(red): false, on_table(green): false, on_table(pink): false, holding(red): false, holding(pink): false}

---------------------------------

 Valid actions so far : 1

 Current State : {on(green, pink): false, holding(green): true, clear(pink): true, hand_empty: false, clear(green): false, on_table(red): true, on(pink, red): true, on(green, green): false, on(red, green): false, on(pink, green): false, on(green, red): false, on(red, red): false, on(red, pink): false, on(pink, pink): false, clear(red): false, on_table(green): false, on_table(pink): false, holding(red): false, holding(pink): false}

 Next Action : put_down(green)

 New State : {holding(green): false, hand_empty: true, clear(green): true, on_table(green): true, on(green, pink): false, clear(pink): true, on_table(red): true, on(pink, red): true, on(green, green): false, on(red, green): false, on(pink, green): false, on(green, red): false, on(red, red): false, on(red, pink): false, on(pink, pink): false, clear(red): false, on_table(pink): false, holding(red): false, holding(pink): false}

---------------------------------

 Valid actions so far : 2

 Current State : {holding(green): false, hand_empty: true, clear(green): true, on_table(green): true, on(green, pink): false, clear(pink): true, on_table(red): true, on(pink, red): true, on(green, green): false, on(red, green): false, on(pink, green): false, on(green, red): false, on(red, red): false, on(red, pink): false, on(pink, pink): false, clear(red): false, on_table(pink): false, holding(red): false, holding(pink): false}

 Next Action : pick_up(pink)


!! INVALID ACTION SEQUENCE:pick_up(pink)

 Computing "Actions To Goal"
[96m  *** Credits ***
[0m[96m  * In operation mode `OneshotPlanner` at line 227 of `/srv/chawak/planning-with-llms/src/unifiedplanning_blocksworld.py`, [0m[96myou are using the following planning engine:
[0m[96m  * Engine name: pyperplan
  * Developers:  Albert-Ludwigs-Universität Freiburg (Yusra Alkhazraji, Matthias Frorath, Markus Grützner, Malte Helmert, Thomas Liebetraut, Robert Mattmüller, Manuela Ortlieb, Jendrik Seipp, Tobias Springenberg, Philip Stahl, Jan Wülfing)
[0m[96m  * Description: [0m[96mPyperplan is a lightweight STRIPS planner written in Python.[0m[96m
[0m[96m
[0m

$$$Proposed actions by GOLD PLAN $$$ : ['unstack the green block from on top of the pink block', 'put down the green block', 'unstack the pink block from on top of the red block', 'put down the pink block', 'pick up the green block', 'stack the green block on top of the red block', 'pick up the pink block', 'stack the pink block on top of the green block', '[PLAN END]'] 
 END
GOALS: {'on_table(red)', 'on(pink, green)', 'on(green, red)'}
Current state: ['hand_empty', 'clear(green)', 'on_table(green)', 'clear(pink)', 'on_table(red)', 'on(pink, red)']
??????????????Goals met:False


--------------------Entering main loop PROBLEM #12--------------------
State in create_ic (('violet', 'brown'), ('teal',))
State in create_goal (('brown', 'violet'), ('teal',))


Blocksworld Problem Initial Values:{clear(teal): true, clear(brown): true, hand_empty: true, on_table(violet): true, on(brown, violet): true, on_table(teal): true, on(teal, teal): false, on(brown, teal): false, on(violet, teal): false, on(teal, brown): false, on(brown, brown): false, on(violet, brown): false, on(teal, violet): false, on(violet, violet): false, clear(violet): false, on_table(brown): false, holding(teal): false, holding(brown): false, holding(violet): false}

Blocksworld Problem Goal State:[on_table(brown), on(violet, brown), on_table(teal)]
Prompt in the chat-template:<bos><start_of_turn>user
I am playing with a set of blocks where I need to arrange the blocks into stacks
        Here are the actions I can do: Pick up a block, Unstack a block from on top of another block, Put down a block, Stack a block on top of another block.
        I have the following restrictions on my actions:
        I can only pick up or unstack one block at a time
        I can only pick up or unstack a block if my hand is empty
        I can only pick up a block if the block is on the table and the block is clear
        A block is clear if the block has no other blocks on top of it and if the block is not picked up
        I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block
        I can only unstack a block from on top of another block if the block I am unstacking is clear
        Once I pick up or unstack a block, I am holding the block
        I can only put down a block that I am holding
        I can only stack a block on top of another block if I am holding the block being stacked
        I can only stack a block on top of another block if the block onto which I am stacking the block is clear
        Once I put down or stack a block, my hand becomes empty
        Once you stack a block on top of a second block, the second block is no longer clear

[STATEMENT]
As initial conditions I have that, the violet block is clear,  the hand is empty, the brown block is on the table, the teal block is on top of the brown block, the violet block is on top of the teal block.
My goal is to have that  the brown block is on the table, the violet block is on top of the brown block, the teal block is on top of the violet block.

My plan is as follows:

[PLAN]
unstack the violet block from on top of the teal block
put down the violet block
unstack the teal block from on top of the brown block
put down the teal block
pick up the violet block
stack the violet block on top of the brown block
pick up the teal block
stack the teal block on top of the violet block
[PLAN END]

[STATEMENT]
As initial conditions I have that, the teal block is clear, the brown block is clear,  the hand is empty, the violet block is on the table, the brown block is on top of the violet block, the teal block is on the table.
My goal is to have that  the brown block is on the table, the violet block is on top of the brown block, the teal block is on the table.

My plan is as follows: 

[PLAN]<end_of_turn>



.......Querying LLM for a plan......... iteration: #0
Response from LLM:: 

[PLAN]
model
Okay, let's analyze the second scenario and devise a plan.

**[STATEMENT]**
As initial conditions I have that, the teal block is clear, the brown block is clear,  the hand is empty, the violet block is on the table, the brown block is on top of the violet block, the teal block is on the table.
My goal is to have that  the brown block is on the table, the violet block is on top of the brown block, the teal block is on the table.

**[PLAN]**

1.  **Pick up the violet block:** The violet block is on the table and clear, and the hand is empty.
2.  **Stack the violet block on top of the brown block:** The brown block is clear, and we are holding the violet block.
3.  **Pick up the teal block:** The teal block is on the table and clear, and the hand is empty.
4.  **Put down the teal block:** The hand is holding the teal block.

**[PLAN END]**

**Explanation of why this plan works:**

*   **Initial State:** We start with the violet block on the table, the brown block on top of the violet block, and the teal block on the table.
*   **Step 1 & 2:** We move the violet block onto the brown block, fulfilling the requirement that the violet block is on top of

After EXTRCAT PLAN ACTIONS: ["Okay, let's analyze the second scenario and devise a plan.", '', '**[STATEMENT]**', 'As initial conditions I have that, the teal block is clear, the brown block is clear,  the hand is empty, the violet block is on the table, the brown block is on top of the violet block, the teal block is on the table.', 'My goal is to have that  the brown block is on the table, the violet block is on top of the brown block, the teal block is on the table.', '', '**']
cannot detect predicate here: Okay, let's analyze the second scenario and devise a plan.
cannot detect predicate here: 
cannot detect predicate here: **[STATEMENT]**
cannot detect predicate here: As initial conditions I have that, the teal block is clear, the brown block is clear,  the hand is empty, the violet block is on the table, the brown block is on top of the violet block, the teal block is on the table.
cannot detect predicate here: My goal is to have that  the brown block is on the table, the violet block is on top of the brown block, the teal block is on the table.
cannot detect predicate here: 
cannot detect predicate here: **


Proposed actions by LLM : [False, False, False, False, False, False, False] 
  END
!!!!!!!!!!!Action statement NOT FROM LIST OF ALLOWED actions!!!!!!!!!!!!

 Computing "Actions To Goal"
[96m  *** Credits ***
[0m[96m  * In operation mode `OneshotPlanner` at line 227 of `/srv/chawak/planning-with-llms/src/unifiedplanning_blocksworld.py`, [0m[96myou are using the following planning engine:
[0m[96m  * Engine name: pyperplan
  * Developers:  Albert-Ludwigs-Universität Freiburg (Yusra Alkhazraji, Matthias Frorath, Markus Grützner, Malte Helmert, Thomas Liebetraut, Robert Mattmüller, Manuela Ortlieb, Jendrik Seipp, Tobias Springenberg, Philip Stahl, Jan Wülfing)
[0m[96m  * Description: [0m[96mPyperplan is a lightweight STRIPS planner written in Python.[0m[96m
[0m[96m
[0m

$$$Proposed actions by GOLD PLAN $$$ : ['unstack the brown block from on top of the violet block', 'put down the brown block', 'pick up the violet block', 'stack the violet block on top of the brown block', '[PLAN END]'] 
 END
GOALS: {'on(violet, brown)', 'on_table(teal)', 'on_table(brown)'}
Current state: ['clear(teal)', 'clear(brown)', 'hand_empty', 'on_table(violet)', 'on(brown, violet)', 'on_table(teal)']
??????????????Goals met:False


--------------------Entering main loop PROBLEM #13--------------------
State in create_ic (('violet', 'teal', 'brown'),)
State in create_goal (('brown', 'teal', 'violet'),)


Blocksworld Problem Initial Values:{clear(brown): true, hand_empty: true, on_table(violet): true, on(teal, violet): true, on(brown, teal): true, on(brown, brown): false, on(violet, brown): false, on(teal, brown): false, on(brown, violet): false, on(violet, violet): false, on(violet, teal): false, on(teal, teal): false, clear(violet): false, clear(teal): false, on_table(brown): false, on_table(teal): false, holding(brown): false, holding(violet): false, holding(teal): false}

Blocksworld Problem Goal State:[on_table(brown), on(teal, brown), on(violet, teal)]
Prompt in the chat-template:<bos><start_of_turn>user
I am playing with a set of blocks where I need to arrange the blocks into stacks
        Here are the actions I can do: Pick up a block, Unstack a block from on top of another block, Put down a block, Stack a block on top of another block.
        I have the following restrictions on my actions:
        I can only pick up or unstack one block at a time
        I can only pick up or unstack a block if my hand is empty
        I can only pick up a block if the block is on the table and the block is clear
        A block is clear if the block has no other blocks on top of it and if the block is not picked up
        I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block
        I can only unstack a block from on top of another block if the block I am unstacking is clear
        Once I pick up or unstack a block, I am holding the block
        I can only put down a block that I am holding
        I can only stack a block on top of another block if I am holding the block being stacked
        I can only stack a block on top of another block if the block onto which I am stacking the block is clear
        Once I put down or stack a block, my hand becomes empty
        Once you stack a block on top of a second block, the second block is no longer clear

[STATEMENT]
As initial conditions I have that, the teal block is clear,  the hand is empty, the brown block is on the table, the violet block is on top of the brown block, the teal block is on top of the violet block.
My goal is to have that  the violet block is on the table, the brown block is on top of the violet block, the teal block is on top of the brown block.

My plan is as follows:

[PLAN]
unstack the teal block from on top of the violet block
put down the teal block
unstack the violet block from on top of the brown block
put down the violet block
pick up the brown block
stack the brown block on top of the violet block
pick up the teal block
stack the teal block on top of the brown block
[PLAN END]

[STATEMENT]
As initial conditions I have that, the brown block is clear,  the hand is empty, the violet block is on the table, the teal block is on top of the violet block, the brown block is on top of the teal block.
My goal is to have that  the brown block is on the table, the teal block is on top of the brown block, the violet block is on top of the teal block.

My plan is as follows: 

[PLAN]<end_of_turn>



.......Querying LLM for a plan......... iteration: #0
Response from LLM:: 

[PLAN]
model
unstack the violet block from on top of the teal block
put down the violet block
unstack the teal block from on top of the brown block
put down the teal block
pick up the brown block
stack the brown block on top of the violet block
pick up the teal block
stack the teal block on top of the brown block
[PLAN END]

After EXTRCAT PLAN ACTIONS: ['unstack the violet block from on top of the teal block', 'put down the violet block', 'unstack the teal block from on top of the brown block', 'put down the teal block', 'pick up the brown block', 'stack the brown block on top of the violet block', 'pick up the teal block', 'stack the teal block on top of the brown block']


Proposed actions by LLM : [('unstack', 'violet', 'teal'), ('put-down', 'violet'), ('unstack', 'teal', 'brown'), ('put-down', 'teal'), ('pick-up', 'brown'), ('stack', 'brown', 'violet'), ('pick-up', 'teal'), ('stack', 'teal', 'brown')] 
  END
LLM PLAN: SequentialPlan:
    unstack(violet, teal)
    put_down(violet)
    unstack(teal, brown)
    put_down(teal)
    pick_up(brown)
    stack(brown, violet)
    pick_up(teal)
    stack(teal, brown)


Entering "CHECK & APPLY"

 Valid actions so far : 0

 Current State : {clear(brown): true, hand_empty: true, on_table(violet): true, on(teal, violet): true, on(brown, teal): true, on(brown, brown): false, on(violet, brown): false, on(teal, brown): false, on(brown, violet): false, on(violet, violet): false, on(violet, teal): false, on(teal, teal): false, clear(violet): false, clear(teal): false, on_table(brown): false, on_table(teal): false, holding(brown): false, holding(violet): false, holding(teal): false}

 Next Action : unstack(violet, teal)


!! INVALID ACTION SEQUENCE:unstack(violet, teal)

 Computing "Actions To Goal"
[96m  *** Credits ***
[0m[96m  * In operation mode `OneshotPlanner` at line 227 of `/srv/chawak/planning-with-llms/src/unifiedplanning_blocksworld.py`, [0m[96myou are using the following planning engine:
[0m[96m  * Engine name: pyperplan
  * Developers:  Albert-Ludwigs-Universität Freiburg (Yusra Alkhazraji, Matthias Frorath, Markus Grützner, Malte Helmert, Thomas Liebetraut, Robert Mattmüller, Manuela Ortlieb, Jendrik Seipp, Tobias Springenberg, Philip Stahl, Jan Wülfing)
[0m[96m  * Description: [0m[96mPyperplan is a lightweight STRIPS planner written in Python.[0m[96m
[0m[96m
[0m

$$$Proposed actions by GOLD PLAN $$$ : ['unstack the brown block from on top of the teal block', 'put down the brown block', 'unstack the teal block from on top of the violet block', 'stack the teal block on top of the brown block', 'pick up the violet block', 'stack the violet block on top of the teal block', '[PLAN END]'] 
 END
GOALS: {'on(teal, brown)', 'on_table(brown)', 'on(violet, teal)'}
Current state: ['clear(brown)', 'hand_empty', 'on_table(violet)', 'on(teal, violet)', 'on(brown, teal)']
??????????????Goals met:False


--------------------Entering main loop PROBLEM #14--------------------
State in create_ic (('pink', 'green'), ('red',))
State in create_goal (('pink', 'red'), ('green',))


Blocksworld Problem Initial Values:{clear(red): true, clear(green): true, hand_empty: true, on_table(pink): true, on(green, pink): true, on_table(red): true, on(red, red): false, on(green, red): false, on(pink, red): false, on(red, green): false, on(green, green): false, on(pink, green): false, on(red, pink): false, on(pink, pink): false, clear(pink): false, on_table(green): false, holding(red): false, holding(green): false, holding(pink): false}

Blocksworld Problem Goal State:[on_table(pink), on(red, pink), on_table(green)]
Prompt in the chat-template:<bos><start_of_turn>user
I am playing with a set of blocks where I need to arrange the blocks into stacks
        Here are the actions I can do: Pick up a block, Unstack a block from on top of another block, Put down a block, Stack a block on top of another block.
        I have the following restrictions on my actions:
        I can only pick up or unstack one block at a time
        I can only pick up or unstack a block if my hand is empty
        I can only pick up a block if the block is on the table and the block is clear
        A block is clear if the block has no other blocks on top of it and if the block is not picked up
        I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block
        I can only unstack a block from on top of another block if the block I am unstacking is clear
        Once I pick up or unstack a block, I am holding the block
        I can only put down a block that I am holding
        I can only stack a block on top of another block if I am holding the block being stacked
        I can only stack a block on top of another block if the block onto which I am stacking the block is clear
        Once I put down or stack a block, my hand becomes empty
        Once you stack a block on top of a second block, the second block is no longer clear

[STATEMENT]
As initial conditions I have that, the green block is clear,  the hand is empty, the pink block is on the table, the red block is on top of the pink block, the green block is on top of the red block.
My goal is to have that  the green block is on the table, the pink block is on top of the green block, the red block is on the table.

My plan is as follows:

[PLAN]
unstack the green block from on top of the red block
put down the green block
unstack the red block from on top of the pink block
put down the red block
pick up the pink block
stack the pink block on top of the green block
[PLAN END]

[STATEMENT]
As initial conditions I have that, the red block is clear, the green block is clear,  the hand is empty, the pink block is on the table, the green block is on top of the pink block, the red block is on the table.
My goal is to have that  the pink block is on the table, the red block is on top of the pink block, the green block is on the table.

My plan is as follows: 

[PLAN]<end_of_turn>



.......Querying LLM for a plan......... iteration: #0
Response from LLM:: 

[PLAN]
model
pick up the red block
stack the red block on top of the pink block
put down the red block
pick up the green block
put down the green block
[PLAN END]

After EXTRCAT PLAN ACTIONS: ['pick up the red block', 'stack the red block on top of the pink block', 'put down the red block', 'pick up the green block', 'put down the green block']


Proposed actions by LLM : [('pick-up', 'red'), ('stack', 'red', 'pink'), ('put-down', 'red'), ('pick-up', 'green'), ('put-down', 'green')] 
  END
LLM PLAN: SequentialPlan:
    pick_up(red)
    stack(red, pink)
    put_down(red)
    pick_up(green)
    put_down(green)


Entering "CHECK & APPLY"

 Valid actions so far : 0

 Current State : {clear(red): true, clear(green): true, hand_empty: true, on_table(pink): true, on(green, pink): true, on_table(red): true, on(red, red): false, on(green, red): false, on(pink, red): false, on(red, green): false, on(green, green): false, on(pink, green): false, on(red, pink): false, on(pink, pink): false, clear(pink): false, on_table(green): false, holding(red): false, holding(green): false, holding(pink): false}

 Next Action : pick_up(red)

 New State : {on_table(red): false, holding(red): true, hand_empty: false, clear(red): false, clear(green): true, on_table(pink): true, on(green, pink): true, on(red, red): false, on(green, red): false, on(pink, red): false, on(red, green): false, on(green, green): false, on(pink, green): false, on(red, pink): false, on(pink, pink): false, clear(pink): false, on_table(green): false, holding(green): false, holding(pink): false}

---------------------------------

 Valid actions so far : 1

 Current State : {on_table(red): false, holding(red): true, hand_empty: false, clear(red): false, clear(green): true, on_table(pink): true, on(green, pink): true, on(red, red): false, on(green, red): false, on(pink, red): false, on(red, green): false, on(green, green): false, on(pink, green): false, on(red, pink): false, on(pink, pink): false, clear(pink): false, on_table(green): false, holding(green): false, holding(pink): false}

 Next Action : stack(red, pink)


!! INVALID ACTION SEQUENCE:stack(red, pink)

 Computing "Actions To Goal"
[96m  *** Credits ***
[0m[96m  * In operation mode `OneshotPlanner` at line 227 of `/srv/chawak/planning-with-llms/src/unifiedplanning_blocksworld.py`, [0m[96myou are using the following planning engine:
[0m[96m  * Engine name: pyperplan
  * Developers:  Albert-Ludwigs-Universität Freiburg (Yusra Alkhazraji, Matthias Frorath, Markus Grützner, Malte Helmert, Thomas Liebetraut, Robert Mattmüller, Manuela Ortlieb, Jendrik Seipp, Tobias Springenberg, Philip Stahl, Jan Wülfing)
[0m[96m  * Description: [0m[96mPyperplan is a lightweight STRIPS planner written in Python.[0m[96m
[0m[96m
[0m

$$$Proposed actions by GOLD PLAN $$$ : ['unstack the green block from on top of the pink block', 'put down the green block', 'pick up the red block', 'stack the red block on top of the pink block', '[PLAN END]'] 
 END
GOALS: {'on_table(green)', 'on_table(pink)', 'on(red, pink)'}
Current state: ['holding(red)', 'clear(green)', 'on_table(pink)', 'on(green, pink)']
??????????????Goals met:False
----------------SFT inference on pre-trained 3 block model,temp=0, on dataset split=val ----------
Empty df
Empty df
Empty df

--- Metrics for model-iteration 3 ---
    Parsable  Attempts  ...  Diff in plan len  GOLD Plan len
0       True         1  ...               1.0            5.0
1       True         1  ...              -1.0            7.0
2       True         1  ...               1.0            7.0
3       True         1  ...               1.0            5.0
4      False         3  ...              -inf           -inf
5       True         1  ...               1.0            5.0
6       True         1  ...              -inf            5.0
7       True         1  ...              -inf            7.0
8       True         1  ...               1.0            5.0
9      False         3  ...              -inf           -inf
10     False         3  ...              -inf           -inf
11      True         1  ...              -inf            9.0
12      True         1  ...              -inf            5.0
13      True         1  ...              -inf            7.0
14      True         1  ...              -inf            5.0

[15 rows x 7 columns]
Metrics saved to ../results/SFT/3_blocks/val/iteration_3
Correction rates are: [0, 0, 0, '0.40']
