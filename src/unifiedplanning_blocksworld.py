# -*- coding: utf-8 -*-
"""UnifiedPlanning-Blocksworld.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xSVEpdjsjwfH0NMaysfcLhxlsbY0IF3j
"""
# Define the problem
problem = Problem("BlocksWorld")

Block = UserType("Block")

# Declare fluents (states)
on = Fluent("on", BoolType(), below=Block, above=Block)
clear = Fluent("clear", BoolType(), block=Block)
holding = Fluent("holding", BoolType(), block=Block)
hand_empty = Fluent("hand_empty", BoolType())

problem.add_fluents([on, clear, holding, hand_empty])

# Declare actions
pick_up = InstantaneousAction("pick_up", block=Block)
block = pick_up.parameter("block")
pick_up.add_precondition(clear(block))
pick_up.add_precondition(hand_empty())
pick_up.add_effect(holding(block), True)
pick_up.add_effect(hand_empty(), False)
pick_up.add_effect(clear(block), False)
problem.add_action(pick_up)

put_down = InstantaneousAction("put_down", block=Block)
block = put_down.parameter("block")
put_down.add_precondition(holding(block))
put_down.add_effect(holding(block), False)
put_down.add_effect(hand_empty(), True)
put_down.add_effect(clear(block), True)
problem.add_action(put_down)

stack = InstantaneousAction("stack", below=Block, above=Block)
below = stack.parameter("below")
above = stack.parameter("above")
stack.add_precondition(holding(above))
stack.add_precondition(clear(below))
stack.add_effect(holding(above), False)
stack.add_effect(clear(below), False)
stack.add_effect(on(below, above), True)
stack.add_effect(hand_empty(), True)
problem.add_action(stack)

unstack = InstantaneousAction("unstack", below=Block, above=Block)
below = unstack.parameter("below")
above = unstack.parameter("above")
unstack.add_precondition(on(below, above))
unstack.add_precondition(clear(above))
unstack.add_effect(on(below, above), False)
unstack.add_effect(holding(above), True)
unstack.add_effect(clear(below), True)
unstack.add_effect(hand_empty(), False)
problem.add_action(unstack)

# Declare objects (blocks)
block_a = Object("A", Block)
block_b = Object("B", Block)
block_c = Object("C", Block)

problem.add_objects([block_a, block_b, block_c])

# Initial state
problem.set_initial_value(on(block_b, block_a), True)
problem.set_initial_value(on(block_c, block_b), True)
problem.set_initial_value(clear(block_a), True)
problem.set_initial_value(clear(block_b), False)
problem.set_initial_value(clear(block_c), False)
problem.set_initial_value(hand_empty(), True)

# Goal state
problem.add_goal(on(block_a, block_b))
problem.add_goal(on(block_b, block_c))

print(problem.kind)

with OneshotPlanner(problem_kind=problem.kind) as planner:
    result = planner.solve(problem)
    print("%s returned: %s" % (planner.name, result.plan))

print(problem.kind)
print(plan.kind)

unified_planning.shortcuts.get_all_applicable_engines(problem_kind=problem.kind)

plan = result.plan
validator = PlanValidator(name='aries-val')
if validator.validate(problem, plan):
    print('The plan is valid')
else:
    print('The plan is invalid')

#does not work, library is not able to find an applicable engine to validate our problem type
'''plan = result.plan
with PlanValidator(problem_kind=problem.kind, plan_kind=plan.kind) as validator:
    if validator.validate(problem, plan):
        print('The plan is valid')
    else:
        print('The plan is invalid')'''