# -*- coding: utf-8 -*-
"""MS-AkankshaChawla-RL on LLMs-MGVariant.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KMZxv95j_z2LdYMLMVcDKUnLrh3TnsgH
"""

!pip install anytree
!pip install transformers
!pip install accelerate
!pip install --upgrade OpenAI
!pip install unified_planning

!pip install httpx==0.23.0

from unified_planning.shortcuts import *

from anytree import Node,RenderTree

from openai import OpenAI
import pickle, sys, copy, re, math
import pandas as pd
import concurrent.futures
import re
import time
import numpy as np

import openai
print(openai.__version__)

#save output to a file
import os
from google.colab import drive
path = '/content/drive'
drive.mount(path)

openai=OpenAI(
    api_key="qQSK4UL7SbIzA1ipuzCCNoItChpioZAv",
    base_url="https://api.deepinfra.com/v1/openai",
)

chat_completion = openai.chat.completions.create(
    model="meta-llama/Meta-Llama-3-70B-Instruct",
    messages=[
        {"role": "user", "content": "Hi!"},],
)
print(chat_completion.choices[0].message.content)

def query_llm(prompt,temperature=0.7, max_tokens=100):
  chat_completion = openai.chat.completions.create(
    model="meta-llama/Meta-Llama-3-70B-Instruct",
    messages=[
        {"role": "user", "content": prompt},],
    temperature=temperature,
    )
  return chat_completion.choices[0].message.content

planbench_generation_ex1 = '''I am playing with a set of blocks where I need to arrange the blocks into stacks
Here are the actions I can do Pick up a block Unstack a block from on top of another block Put down a block Stack a block on top of another block I have the following restrictions on my actions: I can only pick up or unstack one block at a time
I can only pick up or unstack a block if my hand is empty
I can only pick up a block if the block is on the table and the block is clear
A block is clear if the block has no other blocks on top of it and if the block is not picked up
I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block
I can only unstack a block from on top of another block if the block I am unstacking is clear
Once I pick up or unstack a block, I am holding the block
I can only put down a block that I am holding
I can only stack a block on top of another block if I am holding the block being stacked
I can only stack a block on top of another block if the block onto which I am stacking the block is clear
Once I put down or stack a block, my hand becomes empty
Once you stack a block on top of a second block, the second block is no longer clear

[STATEMENT]
As initial conditions I have that, the red block is clear, the orange block is clear, the yellow block is clear, the hand is empty, the orange block is on top of the blue block, the red block is on the table, the blue block is on the table and the yellow block is on the table
My goal is to have that the red block is on top of the blue block and the yellow block is on top of the red block
My plan is as follows:

[PLAN]
unstack the orange block from on top of the blue block
put down the orange block
pick up the red block
stack the red block on top of the blue block
pick up the yellow block
stack the yellow block on top of the red block
[PLAN END]

[STATEMENT]
As initial conditions I have that, the blue block is clear, the yellow block is clear, the hand is empty, the blue block is on top of the orange block, the orange block is on top of the red block, the red block is on the table and the yellow block is on the table
My goal is to have that the red block is on top of the orange block and the blue block is on top of the yellow block
My plan is as follows:

[PLAN]'''

planbench_nextaction_ex1 = '''I am playing with a set of blocks where I need to arrange the blocks into stacks
Here are the actions I can do Pick up a block Unstack a block from on top of another block Put down a block Stack a block on top of another block I have the following restrictions on my actions: I can only pick up or unstack one block at a time
I can only pick up or unstack a block if my hand is empty
I can only pick up a block if the block is on the table and the block is clear
A block is clear if the block has no other blocks on top of it and if the block is not picked up
I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block
I can only unstack a block from on top of another block if the block I am unstacking is clear
Once I pick up or unstack a block, I am holding the block
I can only put down a block that I am holding
I can only stack a block on top of another block if I am holding the block being stacked
I can only stack a block on top of another block if the block onto which I am stacking the block is clear
Once I put down or stack a block, my hand becomes empty
Once you stack a block on top of a second block, the second block is no longer clear

[STATEMENT]
As initial conditions I have that, the red block is clear, the orange block is clear, the yellow block is clear, the hand is empty, the orange block is on top of the blue block, the red block is on the table, the blue block is on the table and the yellow block is on the table
My goal is to have that the red block is on top of the blue block and the yellow block is on top of the red block
I work towards the goal state one action at a time:

[ACTION HISTORY]
unstack the orange block from on top of the blue block
put down the orange block
pick up the red block
[END ACTION HISTORY]

[NEXT ACTION]
stack the red block on top of the blue block
[END NEXT ACTION]

[STATEMENT]
As initial conditions I have that, the blue block is clear, the yellow block is clear, the hand is empty, the blue block is on top of the orange block, the orange block is on top of the red block, the red block is on the table and the yellow block is on the table
My goal is to have that the red block is on top of the orange block and the blue block is on top of the yellow block
I work towards the goal state one action at a time:

[ACTION HISTORY]
[END ACTION HISTORY]

[NEXT ACTION]
'''

r = query_llm(planbench_ex1)
print(r)

def extract_plan_action_strings(plan_output):
    actions = plan_output.split('[PLAN]')[1].split('[PLAN END]')[0].strip().split('\n')
    actions = [a.strip() for a in actions]
    return actions

def extract_next_action_string(plan_output):
    return plan_output.split('[NEXT ACTION]')[1].split('[END NEXT ACTION]')[0].strip()

def parse_action(action):
    predicate = action.split(' ')[0]
    if predicate.lower() == 'unstack':
        pattern = r"unstack the (\w+) block from on top of the (\w+) block"
        replacement = r"(unstack \1 \2)"
        return re.sub(pattern, replacement, action)
    if predicate.lower() == 'stack':
        pattern = r"stack the (\w+) block on top of the (\w+) block"
        replacement = r"(stack \1 \2)"
        return re.sub(pattern, replacement, action)
    if predicate.lower() == 'put':
        pattern = r"put down the (\w+) block"
        replacement = r"(put-down \1)"
        return re.sub(pattern, replacement, action)
    if predicate.lower() == 'pick':
        pattern = r"pick up the (\w+) block"
        replacement = r"(pick-up \1)"
        return re.sub(pattern, replacement, action)

def extract_plan(plan_output):
    actions = extract_plan_action_strings(plan_output)
    parsed_actions = [parse_action(a) for a in actions]
    return parsed_actions

def extract_next_action(plan_output):
    return parse_action(extract_next_action_string(plan_output))

extract_plan(r)

rnx = query_llm(planbench_nextaction_ex1)
print(rnx)

extract_next_action(rnx)

#dep code
'''#action_space=['continue_','backtrack','reflect','terminate']'''

# add a child node to the given parent
def continue_(parent, name,text,pddl):
    return Node(name,parent=parent,text=text,pddl=pddl)

#dep code
'''#update text element of current node
def reflect(node):
    #llm call for new reasoning on reflection
    node.text=new_text'''

def progress(current_node):

  #get action reasoning text till current state
  #reasoning_so_far = "\n".join(node.name for node in current_node.path)
  #print("Reasoning so far to current state:::",reasoning_so_far)

  #get DFS path till current state
  path_element= str(current_node.path[-1])
  path = path_element.split("'", 2)[1]
  path=path.replace("/","\n")
  #print("DFS Path to the current state:::",path)

  return path

def get_PDDL_noAction(node):
  prompt=("I am playing with a set of blocks where I need to arrange the blocks into stacks."
  ''
  f"This is my current state: {node}"
  "Convert this game state to PDDL and frame your response within <PDDL> and </PDDL> tags."
  "Here is an example PDDL in blocksworld domain with 3 blocks: Red, Blue, Green. The red block is on the table. The blue block is on top of red block. The green block is on top of the blue block."
  "The current state of game is defined in : (define (problem)" #RBG
  "(:domain blocksworld)"
  "(:objects Red Blue Green)"
  "(:init (on-table Red)"
  "((on Blue Red)(on Green Blue))"
  "(clear Green)"
  "(arm-empty))"
  )

  response=query_llm(prompt)

  #print(response)

  pattern=r"(\(:init\s*\(.*\s*\(.*\s*\(.*\s*\(.*\s*\(.*\s*\))" #fetch out only the PDDL
  match=re.search(pattern,response)
  if match:
    response=match.group(1)
  return response

#dummy run
#RGB
print('Dummy run: get_PDDL_noAction')
goal_state='Red block is on top of table, Green block is on top of Red block, Blue block is on top of Green block'
print(get_PDDL_noAction(goal_state))

def get_goal(goal_state):
  goal_state=get_PDDL_noAction(goal_state)
  print(goal_state)
  goal_state=goal_state.replace('init','goal')
  pattern=r"(\(:goal\s*\(.*\s*\(.*\s*\(.*\s*\(.*)"
  match=re.search(pattern,goal_state)
  if match:
    goal_state=match.group(1)
  goal_state=goal_state+')'
  return goal_state
Goal=get_goal(goal_state)
print(Goal)

#one-shot
def get_PDDL(parent,action,goal_state):

  print('............................Enter get PDDL............................')
  prompt=("I am playing with a set of blocks where I need to arrange the blocks into stacks."
  f"This is my current state of the game: {parent.pddl}"
  f"This is my next action: {action}"
  f"This is my goal state: {goal_state}"
  "Take the next action step and convert this new game state into a PDDL in blocksworld domain."
  "Give the new state of the game in <PDDL> and </PDDL> tags."

  #example PDDL
  #RBG
  "Here is an example in the blocksworld domain with 3 blocks: Red,Blue,Green."
  "Current state of game:"
  "<current_state>"
  "(define (problem)"
  "(:domain blocksworld)"
  "(:objects Red Blue Green)"
  "(:init (on-table Red) (on-table Green)(on-table Blue)"
  "(clear Red)(clear Green)(clear Blue)"
  "(arm-empty))"
  "(:goal (on-table Red)((Blue on Red) and (Green on Blue))(clear Green))"
  "</current_state>"

  "Next action: Pick up Blue block"
  "Goal state is: Red Block is on the table. Blue block is on top of Red block."
  "Green block is the topmost block, and it is on top of Blue block."

  "New state PDDL of game:"
  "<PDDL>(define (problem)"
  "(:domain blocksworld)"
  "(:objects Red Blue Green)"
  "(:init (on-table Green) (on-table Red)"
  "(clear Red)  (clear Green) (holding-Blue))"
  "(:goal (on-table Red)((Blue on Red) and (Green on Blue)"
  "(clear Green))</PDDL>"
  )

  response=query_llm(prompt)
  #print(response)
  pattern=r"(?s)<PDDL>(.*?)</PDDL>"
  match=re.search(pattern,response)
  if match:
    response=match.group(1)

  #append goal state EXPLICTLY
  index=response.find(":goal") #find index @ which we get 'goal'
  response=response[:index]+Goal

  #print('goal_state',Goal)
  print(response)
  print('..........................EXIT get PDDL...............................')

  return response

#dummy-run
#RGB
print('Dummy run: get_PDDL')
goal_state=("Red block is on top of table, Green block is on top of Red block,"
"Blue block is the topmost block and it is on top of Green block")
initial_condition='Red block is on top of table, Green block is on top of table, Blue block is on top of table'
pddl=("(define (problem)"
  "(:domain blocksworld)"
  "(:objects Red Green Blue)"
  "(: (on-table Red) (on-table Green) (on-table Blue) (clear Red)(clear Green)(clear Blue)"
    "(arm-empty)))"
  "(:goal (on-table Red)((Green on Red) and (Blue on Green))(clear Blue))"
  )
action='Pick up Green'
root=Node(name='start state',text=initial_condition,pddl=pddl)

print(get_PDDL(root,action,goal_state))

#zero-shot

def policy_model(current_node,goal_state,initial_condition):

  print('.........................Enter policy model.........with node......................', current_node)

  path=progress(current_node)
  print("\n******* Path to current state *********",path)

  #state_PDDL=get_PDDL(current_node,goal_state)
  #print("*******PDDL of current state *********",current_node.pddl)

  policy_prompt=policy_prompt = ("I am playing with a set of blocks where I need to arrange the blocks into stacks."
  " Here are the actions I can choose from:"
  " * Pick up a block from the table" #added : from the table
  " * Stack a block on top of another block"
  " * Unstack a block from on top of another block"
  " * Put down a block on the table" #added: on the table
  " * Pause and think again about my actions so far and how I want to proceed from here" # reflection
  " * Decide this path is a dead end and backtrack to an earlier step"                   # backtracking
  " * If goal state has reached, STOP."                                                  # terminate

  "I have the following restrictions on my action choice:" #?? change to 'game rules'
  "I can only pick up or unstack one block at a time."
  "I can only pick up or unstack a block if my hand is empty."
  "I can only pick up a block if the block is on the table and the block is clear."
  "A block is clear if the block has no other blocks on top of it and if the block is not picked up."
  "I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block."
  "I can only unstack a block from on top of another block if the block I am unstacking is clear."
  "Once I pick up or unstack a block, I am holding the block."
  "I can only put down a block that I am holding."
  "I can only stack a block on top of another block if I am holding the block being stacked."
  "I can only stack a block on top of another block if the block onto which I am stacking the block is clear."
  "Once I put down or stack a block, my hand becomes empty. Once you stack a block on top of a second block, the second block is no longer clear."
  "I can only backtrack one step at a time."

  "[STATEMENT]"
  #f"[STATEMENT] As initial conditions I have that, {initial_condition}"
  #f"My goal is to have that {goal_state}"
  f"So far, this is what I have done: {path}"
  f"Current state of my game followed by goal is: {current_node.pddl}"
  f"Choose your next action towards reaching the goal and provide reason for that action."
  f"Frame your action in <ACTION> and </ACTION> tags, and your reasons in <REASON> and </REASON> tags."
  #"Given the actions and restrictions, my next action is : [ACTION]"
  #"I chose this action due to this reasoning: [REASON]"
  )

  response=query_llm(policy_prompt)
  print(response)

  #pattern=r".*?<ACTION>\s*(.+?)</ACTION>\s*.*<REASON>\s*(.+?)</REASON>"
  pattern = r"(?s)<ACTION>\s*(.+?)</ACTION>\s*.*?<REASON>\s*(.+?)</REASON>" #gpt suggestion
  match=re.search(pattern,response)
  if match:
    action=match.group(1)
    reason=match.group(2)

  #print('ACTION:  ',action,'\n\nREASON:',reason)

  print('.........................EXIT policy model.............................')
  return action,reason


#dummy-run
#RBG
goal_state='Red block is on top of table. Blue block is on top of Red block. Green block is the topmost block and it is on top of Blue block.'
initial_condition='Red block is on top of table, Green block is on top of table, Blue block is on top of table'
pddl=("(define (problem)"
  "(:domain blocksworld)"
  "(:objects Red Green Blue)"
  "(:init (on-table Red) (on-table Green) (on-table Blue) (clear Red) (clear Green)(clear Blue)"
    "(arm-empty)))"
  "(:goal (on-table Red)((Blue on Red) and (Green on Blue))(clear Green))"
  )
root=Node(name='start state',text=initial_condition,pddl=pddl)

policy_model(root,goal_state,initial_condition)

#one-shot

def oneShot_policy_model(current_node,goal_state,initial_condition):

  print('.........................Enter policy model.........with node......................', current_node)

  path=progress(current_node)
  print("\n******* Path to current state *********",path)

  #state_PDDL=get_PDDL(current_node,goal_state)
  #print("*******PDDL of current state *********",current_node.pddl)

  #example
  #GRB
  example_initial_condition='Red block is on top of table, Green block is on top of table, Blue block is on top of table'
  example_goal_state="Green block is on top of the table. Red block is on top of the Green block. Blue block is the topmost block, and it is on Red block."
  example_pddl=("(define (problem)"
  "(:domain blocksworld)"
  "(:objects Red Green Blue)"
  "(:init (on-table Red) (on-table Green) (on-table Blue) (clear Red) (clear Green)(clear Blue)"
    "(arm-empty)))"
  "(:goal (on-table Green)((Red on Green) and (Blue on Red))(clear Blue))"
  )

  #added: on the table
  policy_prompt=f"""I am playing with a set of blocks where I need to arrange the blocks into stacks.
  Here are the actions I can choose from:
  * Pick up a block from the table
  * Stack a block on top of another block
  * Unstack a block from on top of another block
  * Put down a block on the table
  * Pause and think again about my actions so far and how I want to proceed from here
  * Decide this path is a dead end and backtrack to an earlier step
  * If goal state has reached, STOP.

  I have the following restrictions on my action choice:
  I can only pick up or unstack one block at a time.
  I can only pick up or unstack a block if my hand is empty.
  I can only pick up a block if the block is on the table and the block is clear.
  A block is clear if the block has no other blocks on top of it and if the block is not picked up.
  I can only unstack a block from on top of another block if the block I am unstacking was really on top of the other block.
  I can only unstack a block from on top of another block if the block I am unstacking is clear.
  Once I pick up or unstack a block, I am holding the block.
  I can only put down a block that I am holding.
  I can only stack a block on top of another block if I am holding the block being stacked.
  I can only stack a block on top of another block if the block onto which I am stacking the block is clear.
  Once I put down or stack a block, my hand becomes empty. Once you stack a block on top of a second block, the second block is no longer clear.
  I can only backtrack one step at a time.


  This is an example for my guidance.
  [EXAMPLE]
  My starting condition is:{example_initial_condition}
  My goal is:{example_goal_state}
  Initial condition, followed by goal state for example in PDDL is {example_pddl}
  My plan is: <plan>
  - Pick up red block
  - Stack red block on top of green block
  - Pick up blue block
  - Stack blue block on top of red block</plan>
  [/EXAMPLE]

  [PROBLEM STATEMENT]
  As initial conditions I have that, {initial_condition}
  My goal is to have that {goal_state}
  So far, this is what I have done: {path}
  Current state of my game followed by goal is: {current_node.pddl}
  Choose your next action towards reaching the goal and provide reason for that action.
  Frame your action in <ACTION> and </ACTION> tags, and your reasons in <REASON> and </REASON> tags.
  [/PROBLEM STATEMENT]"""
  #"Given the actions and restrictions, my next action is : [ACTION]"
  #"I chose this action due to this reasoning: [REASON]"


  response=query_llm(policy_prompt)
  print(response)

  #pattern=r".*?<ACTION>\s*(.+?)</ACTION>\s*.*<REASON>\s*(.+?)</REASON>"
  pattern = r"(?s)<ACTION>\s*(.+?)</ACTION>\s*.*?<REASON>\s*(.+?)</REASON>" #gpt suggestion
  match=re.search(pattern,response)
  if match:
    action=match.group(1)
    reason=match.group(2)

  #print('ACTION:  ',action,'\n\nREASON:',reason)

  print('.........................EXIT policy model.............................')
  return action,reason


#dummy-run
#RBG
goal_state='Red block is on top of table. Blue block is on top of Red block. Green block is the topmost block and it is on top of Blue block.'
initial_condition='Red block is on top of table, Green block is on top of table, Blue block is on top of table'
pddl=("(define (problem)"
  "(:domain blocksworld)"
  "(:objects Red Green Blue)"
  "(:init (on-table Red) (on-table Green) (on-table Blue) (clear Red) (clear Green)(clear Blue)"
    "(arm-empty)))"
  "(:goal (on-table Red)((Blue on Red) and (Green on Blue))(clear Green))"
  )
root=Node(name='start state',text=initial_condition,pddl=pddl)

oneShot_policy_model(root,goal_state,initial_condition)

#reward model
# how to extract numerical val for reward??

def reward_model(current_state,action_chosen):

  path_element=str(current_state.path[-1])
  path = path_element.split("'", 2)[1]

def termination_check(current_node):

  print('\n\n........ENTER termination check........\n')


  termination_prompt=(f"I am playing with a set of blocks where I need to arrange the blocks into stacks."
  f" Current state of my game followed by goal state is: {current_node.pddl}"
  " Answer in Yes or No. Have I reached the goal?")
  print('TERMINATION PROMPT:\t',termination_prompt)

  term_res=query_llm(termination_prompt)
  print('TERM_RES:', term_res)

  print('\n........EXIT termination check........\n')
  return term_res

#dummy run
initial_condition='Red block is on top of table, Green block is on top of table, Blue block is on top of table'
pddl=("(define (problem)"
  "(:domain blocksworld)"
  "(:objects Red Green Blue)"
  "(:init (on-table Red) (on-table Green) (on-table Blue) (clear Red) (clear Green)(clear Blue)"
    "(arm-empty)))"
  "(:goal (on-table Red)((Green on Red) and (Blue on Green))(clear Blue))"
  )
root=Node(name='start state',text=initial_condition,pddl=pddl)

termination_check(root)

# main fuction code
def main_code():
  counter=0
  goal_state='Red block is on top of table, Green block is on top of Red block, Blue block is on top of Green block'
  initial_condition='Red block is on top of table, Green block is on top of table, Blue block is on top of table'
  pddl=("(define (problem)"
  "(:domain blocksworld)"
  "(:objects Red Green Blue)"
  "(:init (on-table Red) (on-table Green) (on-table Blue) (clear Red) (clear Green)(clear Blue)"
    "(arm-empty)))"
  "(:goal (on-table Red)((Green on Red) and (Blue on Green))(clear Blue))"
  )

  root=Node(name='start state',text=initial_condition,pddl=pddl)
  current_node=root
  get_goal(goal_state)
  print("\n GET GOAL:",Goal)

  term_res=termination_check(current_node)

  while 'No' or 'NO' or 'no' in term_res:
    print("\n\n FIGURING OUT SOLUTION.......",counter)

    #choosing new state using policy model
    #new_state,text = policy_model(current_node,goal_state, initial_condition)

    ##choosing new state using one-shot policy model
    new_state,text = oneShot_policy_model(current_node,goal_state, initial_condition)

    #call action fuction for reasoning tree modification
    pddl=get_PDDL(current_node,new_state,goal_state) #current node has not been updated yet, hence it IS the parent

    #update current node
    current_node=continue_(current_node,new_state,text,pddl)

    print('\n\n###############################   NODE UPDATE:    #######################################',current_node)

    term_res=termination_check(current_node)
    print('TERM_RES in main:', term_res)
    counter+=1

  if 'Yes' in term_res:
    print("Goal state reached")

#%%capture cap
main_code()

file_path=path+'/MyDrive/RE_strawberry/output.txt'
f = open(file_path, "w")
print(cap, file=f)
f.close()